from pathlib import Path

import numpy as np
import pandas as pd

from tlo import DateOffset, Module, Parameter, Property, Types, logging
from tlo.events import Event, IndividualScopeEventMixin, PopulationScopeEventMixin, RegularEvent
from tlo.lm import LinearModel
from tlo.methods import Metadata, demography, newborn_outcomes_lm
from tlo.methods.causes import Cause
from tlo.methods.dxmanager import DxTest
from tlo.methods.healthsystem import HSI_Event
from tlo.methods.hiv import HSI_Hiv_TestAndRefer
from tlo.util import BitsetHandler
from tlo.methods.postnatal_supervisor import PostnatalWeekOneNeonatalEvent


logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


class NewbornOutcomes(Module):
    """
    This module is responsible for simulating the key conditions/complications experienced by a neonate immediately
    following birth (either at home or in a health facility). Important predictors of newborn health also generated by
    this model include low birth weight and small for gestational age. Complications modelled include early-onset
    neonatal sepsis, neonatal encephalopathy, congenital birth anomalies, failure to breathe at birth and complications
    of prematurity (respiratory distress syndrome and retinopathy) The focus of this module is day 0-1 of a newborns
     life and any complications experienced by neonates in the later neonatal period (defined here as day 2- day 28)
     are managed via the PostnatalSupervisorModule. This module also manages any interventions that are delivered by
     skilled birth   attendants to newborns following a facility delivery (or for mothers who seek care for newborns
     immediately following birth) including essential newborn care, assistance with breastfeeding,
      case-management of sepsis, neonatal resuscitation and kangaroo mother care for low birth weight babies.
    """

    def __init__(self, name=None, resourcefilepath=None):
        super().__init__(name)
        self.resourcefilepath = resourcefilepath

        # First we define dictionaries which will store the current parameters of interest (to allow parameters to
        # change between 2010 and 2020) and the linear models
        self.current_parameters = dict()
        self.nb_linear_models = dict()

        # This dictionary will store information related to the neonates delivery that does not need to be stored in
        # the main data frame
        self.newborn_care_info = dict()

    INIT_DEPENDENCIES = {'Demography', 'HealthSystem', 'SymptomManager', }

    OPTIONAL_INIT_DEPENDENCIES = {'HealthBurden'}

    ADDITIONAL_DEPENDENCIES = {
        'CareOfWomenDuringPregnancy',
        'Labour',
        'PostnatalSupervisor',
        'PregnancySupervisor'
    }

    METADATA = {
        Metadata.DISEASE_MODULE,
        Metadata.USES_HEALTHSYSTEM,
        Metadata.USES_HEALTHBURDEN,
    }

    # Declare Causes of Death
    CAUSES_OF_DEATH = {
        'early_onset_neonatal_sepsis': Cause(gbd_causes='Neonatal disorders', label='Neonatal Disorders'),
        'late_onset_neonatal_sepsis': Cause(gbd_causes='Neonatal disorders', label='Neonatal Disorders'),
        'encephalopathy': Cause(gbd_causes='Neonatal disorders', label='Neonatal Disorders'),
        'neonatal_respiratory_depression': Cause(gbd_causes='Neonatal disorders', label='Neonatal Disorders'),
        'preterm_other': Cause(gbd_causes='Neonatal disorders', label='Neonatal Disorders'),
        'respiratory_distress_syndrome': Cause(gbd_causes='Neonatal disorders', label='Neonatal Disorders'),
        'congenital_heart_anomaly': Cause(gbd_causes='Neonatal disorders', label='Neonatal Disorders'),
        'limb_or_musculoskeletal_anomaly': Cause(gbd_causes='Neonatal disorders', label='Neonatal Disorders'),
        'urogenital_anomaly': Cause(gbd_causes='Neonatal disorders', label='Neonatal Disorders'),
        'digestive_anomaly': Cause(gbd_causes='Neonatal disorders', label='Neonatal Disorders'),
        'other_anomaly': Cause(gbd_causes='Neonatal disorders', label='Neonatal Disorders'),

    }

    # Declare Causes of Disability
    CAUSES_OF_DISABILITY = {
        'Retinopathy of Prematurity':
            Cause(gbd_causes='Neonatal disorders', label='Neonatal Disorders'),
        'Neonatal Encephalopathy':
            Cause(gbd_causes='Neonatal disorders', label='Neonatal Disorders'),
        'Neonatal Sepsis Long term Disability':
            Cause(gbd_causes='Neonatal disorders', label='Neonatal Disorders'),
        'Preterm Birth Disability':
            Cause(gbd_causes='Neonatal disorders', label='Neonatal Disorders')
    }

    PARAMETERS = {
        # CARE SEEKING
        'prob_care_seeking_for_complication': Parameter(
            Types.LIST, 'baseline probability that a mother will seek care for an unwell neonate following delivery'),
        'prob_day_reaches_week_one_event': Parameter(
            Types.LIST, 'Probabilities for day of attendance at postnatal week one event'),

        # EARLY ONSET SEPSIS...
        'prob_early_onset_neonatal_sepsis_day_0': Parameter(
            Types.LIST, 'baseline probability of a neonate developing early onset sepsis between birth and 24hrs'),
        'rr_eons_maternal_chorio': Parameter(
            Types.LIST, 'relative risk of EONS in newborns whose mothers have chorioamnionitis'),
        'rr_eons_maternal_prom': Parameter(
            Types.LIST, 'relative risk of EONS in newborns whose mothers have PROM'),
        'rr_eons_preterm_neonate': Parameter(
            Types.LIST, 'relative risk of EONS in preterm newborns'),
        'cfr_neonatal_sepsis': Parameter(
            Types.LIST, 'case fatality rate for a neonate due to neonatal sepsis'),
        'cfr_late_onset_neonatal_sepsis': Parameter(
            Types.LIST, 'case fatality rate for a neonate due to neonatal sepsis'),

        # NOT BREATHING AT BIRTH....
        'prob_failure_to_transition': Parameter(
            Types.LIST, 'baseline probability of a neonate developing intrapartum related complications '
                        '(previously birth asphyxia) following delivery '),
        'prob_enceph_no_resus': Parameter(
            Types.LIST, 'Probability of a newborn who was not breathing at birth, and didnt receive resuscitation, '
                        'developing encephalopathy '),
        'cfr_failed_to_transition': Parameter(
            Types.LIST, 'case fatality rate for a neonate following failure to transition'),

        # ENCEPHALOPATHY AND RESPIRATORY DEPRESSION...
        'prob_encephalopathy': Parameter(
            Types.LIST, 'baseline odds of a neonate developing encephalopathy of any severity following birth'),
        'rr_enceph_neonatal_sepsis': Parameter(
            Types.LIST, 'relative risk of neonatal encephalopathy if the neonate is also septic'),
        'rr_enceph_obstructed_labour': Parameter(
            Types.LIST, 'relative risk  for encephalopathy if the mothers labour was obstructed'),
        'rr_enceph_acute_hypoxic_event': Parameter(
            Types.LIST, 'relative risk for encephalopathy if the mothers experience an acute event in labour'),
        'prob_enceph_severity': Parameter(
            Types.LIST, 'probability of the severity of encephalopathy in a newborn who is encephalopathic'),
        'prob_mild_impairment_post_enceph': Parameter(
            Types.LIST, 'probability of the mild neurodevelopmental impairment in survivors of encephalopathy'),
        'prob_mod_severe_impairment_post_enceph': Parameter(
            Types.LIST, 'probability of the moderate or severe neurodevelopmental impairment in survivors of '
                        'encephalopathy'),
        'cfr_enceph': Parameter(
            Types.LIST, 'case fatality rate for a neonate due to mild encephalopathy'),
        'cfr_multiplier_severe_enceph': Parameter(
            Types.LIST, 'multiplier for risk of death in a neonate with severe encephalopathy'),

        # COMPLICATIONS OF PREMATURITY...
        'prob_respiratory_distress_preterm': Parameter(
            Types.LIST, 'probability that a preterm infant will experience respiratory distress at birth'),
        'rr_rds_maternal_diabetes_mellitus': Parameter(
            Types.LIST, 'relative risk of RDS in a preterm newborn whose mother has DM'),
        'rr_rds_maternal_gestational_diab': Parameter(
            Types.LIST, 'relative risk of RDS in a preterm newborn whose mother has gestational diabetes'),
        'cfr_respiratory_distress_syndrome': Parameter(
            Types.LIST, 'case fatality rate for respiratory distress syndrome of prematurity'),
        'prob_mild_disability_preterm_<32weeks': Parameter(
            Types.LIST, 'probability of mild long term neurodevelopmental disability in preterm infants born at less '
                        'than 32 weeks gestation'),
        'prob_mod_severe_disability_preterm_<32weeks': Parameter(
            Types.LIST, 'probability of moderate/severe longterm neurodevelopmental disability in preterm infants born '
                        'at less than 32 weeks gestation'),
        'prob_mild_disability_preterm_32_36weeks': Parameter(
            Types.LIST, 'probability of mild long term neurodevelopmental disability in preterm infants born between 32'
                        ' and 36 weeks gestation'),
        'prob_mod_severe_disability_preterm_32_36weeks': Parameter(
            Types.LIST, 'probability of moderate/severe long term neurodevelopmental disability in preterm infants born'
                        ' between 32 and 36 weeks gestation'),
        'prob_retinopathy_preterm': Parameter(
            Types.LIST, 'baseline probability of a preterm neonate developing retinopathy of prematurity '),
        'prob_retinopathy_severity': Parameter(
            Types.LIST, 'probabilities of severity of retinopathy'),
        'cfr_preterm_birth': Parameter(
            Types.LIST, 'case fatality rate for a neonate born prematurely'),
        'rr_preterm_death_early_preterm': Parameter(
            Types.LIST, 'relative risk of preterm death in early preterm neonates '),
        'prob_preterm_death_by_day': Parameter(
            Types.LIST, 'probability of death due to preterm complications occurring on days 0-14'),

        # CONGENITAL ANOMALIES...
        'prob_congenital_heart_anomaly': Parameter(
            Types.LIST, 'Probability of a congenital heart anomaly in the newborn'),
        'prob_limb_musc_skeletal_anomaly': Parameter(
            Types.LIST, 'Probability of a congenital limb or musculoskeletal anomaly in the newborn'),
        'prob_urogenital_anomaly': Parameter(
            Types.LIST, 'Probability of a congenital urogenital anomaly in the newborn'),
        'prob_digestive_anomaly': Parameter(
            Types.LIST, 'Probability of a congenital digestive anomaly in the newborn'),
        'prob_other_anomaly': Parameter(
            Types.LIST, 'Probability of a other congenital anomalies in the newborn'),
        'cfr_congenital_heart_anomaly': Parameter(
            Types.LIST, 'case fatality rate for newborns with congenital heart anomalies'),
        'cfr_limb_or_musculoskeletal_anomaly': Parameter(
            Types.LIST, 'case fatality rate for newborns with congenital limb/musculoskeletal anomalies'),
        'cfr_urogenital_anomaly': Parameter(
            Types.LIST, 'case fatality rate for newborns with congenital urogenital anomalies'),
        'cfr_digestive_anomaly': Parameter(
            Types.LIST, 'case fatality rate for newborns with congenital digestive anomalies'),
        'cfr_other_anomaly': Parameter(
            Types.LIST, 'case fatality rate for newborns with other congenital anomalies'),

        # BREASTFEEDING...
        'prob_early_breastfeeding_hb': Parameter(
            Types.LIST, 'probability that a neonate will be breastfed within the first hour following birth when '
                        'delivered at home'),
        'prob_breastfeeding_type': Parameter(
            Types.LIST, 'probabilities that a woman is 1.) not breastfeeding 2.) non-exclusively breastfeeding '
                        '3.)exclusively breastfeeding at birth (until 6 months)'),
        'prob_early_breastfeeding_hf': Parameter(
            Types.LIST, 'probability that a neonate will be breastfed within the first hour following birth when '
                        'delivered at a health facility'),

        # POSTNATAL CARE..
        'prob_pnc_check_newborn': Parameter(
            Types.LIST, 'probability that a neonate will receive a full postnatal check'),
        'prob_timings_pnc_newborns': Parameter(
            Types.LIST, 'probabilities that a postnatal check will happen before or after 48 hours alive'),

        # TREATMENT...
        'treatment_effect_inj_abx_sep': Parameter(
            Types.LIST, 'effect of injectable antibiotics treatment on reducing mortality from sepsis'),
        'treatment_effect_supp_care_sep': Parameter(
            Types.LIST, 'effect of full supportive care treatment on reducing mortality from sepsis'),
        'treatment_effect_cord_care': Parameter(
            Types.LIST, 'effect of full supportive care treatment on reducing incidence of sepsis'),
        'treatment_effect_clean_birth': Parameter(
            Types.LIST, 'effect of clean birth practices on reducing incidence of sepsis'),
        'treatment_effect_early_init_bf': Parameter(
            Types.LIST, 'effect of early initiation of breastfeeding on reducing incidence of sepsis'),
        'treatment_effect_resuscitation': Parameter(
            Types.LIST, 'effect of resuscitation on newborn mortality associated with encephalopathy'),
        'treatment_effect_resuscitation_preterm': Parameter(
            Types.LIST, 'effect of delayed resuscitation on newborn mortality associated with prematurity'),
        'treatment_effect_abx_prom': Parameter(
            Types.LIST, 'effect of antibiotics given to mothers experience PROM on risk of newborn sepsis '),
        'treatment_effect_steroid_preterm': Parameter(
            Types.LIST, 'relative risk of death for preterm neonates following administration of antenatal '
                        'corticosteroids'),
        'treatment_effect_kmc': Parameter(
            Types.LIST, 'treatment effect of kangaroo mother care on preterm mortality'),

        # ASSESSMENT SENSITIVITY AND SQUEEZE THRESHOLDS...
        'sensitivity_of_assessment_of_neonatal_sepsis_hc': Parameter(
            Types.LIST, 'sensitivity of dx_test assessment of neonatal sepsis in level 1 health centre'),
        'sensitivity_of_assessment_of_neonatal_sepsis_hp': Parameter(
            Types.LIST, 'sensitivity of dx_test assessment of neonatal sepsis in level 1 hospital'),
        'sensitivity_of_assessment_of_ftt_hc': Parameter(
            Types.LIST, 'sensitivity of dx_test assessment of failure to transition in level 1 health centre'),
        'sensitivity_of_assessment_of_ftt_hp': Parameter(
            Types.LIST, 'sensitivity of dx_test assessment of failure to transition in level 1 hospital'),
        'sensitivity_of_assessment_of_lbw_hc': Parameter(
            Types.LIST, 'sensitivity of dx_test assessment of low birth weight in level 1 health centre'),
        'sensitivity_of_assessment_of_lbw_hp': Parameter(
            Types.LIST, 'sensitivity of dx_test assessment of low birth weight in level 1 hospital'),
        'squeeze_threshold_essential_newborn_care': Parameter(
            Types.LIST, 'squeeze factor threshold below which essential newborn care can be given'),
        'squeeze_threshold_kmc': Parameter(
            Types.LIST, 'squeeze factor threshold below which essential kangaroo mother care can be given'),
        'squeeze_threshold_assist_with_breast_feeding': Parameter(
            Types.LIST, 'squeeze factor threshold below which assistance with breastfeeding can be given'),
        'squeeze_threshold_neonatal_resus': Parameter(
            Types.LIST, 'squeeze factor threshold below which neonatal resuscitation can be given'),
        'squeeze_threshold_sepsis_treatment': Parameter(
            Types.LIST, 'squeeze factor threshold below which sepsis treatment can be given'),
    }

    PROPERTIES = {
        'nb_is_twin': Property(Types.BOOL, 'whether this is part of a twin pair'),
        'nb_twin_sibling_id': Property(Types.INT, 'id number of this twins sibling'),
        'nb_early_preterm': Property(Types.BOOL, 'whether this neonate has been born early preterm (24-33 weeks '
                                                 'gestation)'),
        'nb_late_preterm': Property(Types.BOOL, 'whether this neonate has been born late preterm (34-36 weeks '
                                                'gestation)'),
        'nb_preterm_birth_disab': Property(Types.CATEGORICAL, 'Disability associated with preterm delivery',
                                           categories=['none', 'mild_motor_and_cog', 'mild_motor', 'moderate_motor',
                                                       'severe_motor']),
        'nb_congenital_anomaly': Property(Types.INT, 'Types of congenital anomaly of the newborn stored as bitset'),
        'nb_early_onset_neonatal_sepsis': Property(Types.BOOL, 'whether this neonate has developed neonatal sepsis'
                                                               ' following birth'),
        'nb_inj_abx_neonatal_sepsis': Property(Types.BOOL, 'If this neonate has injectable antibiotics as treatment '
                                                           'for neonatal sepsis'),
        'nb_supp_care_neonatal_sepsis': Property(Types.BOOL, 'If this neonate has received full supportive care for '
                                                             'neonatal sepsis (in hospital)'),
        'nb_neonatal_sepsis_disab': Property(Types.CATEGORICAL, 'Disability associated neonatal sepsis',
                                             categories=['none', 'mild_motor_and_cog', 'mild_motor',
                                                         'moderate_motor', 'severe_motor']),
        'nb_preterm_respiratory_distress': Property(Types.BOOL, 'whether this preterm newborn has respiratory '
                                                                'distress syndrome (RDS)'),
        'nb_not_breathing_at_birth': Property(Types.BOOL, 'whether this neonate has failed to transition to breathing '
                                                          'on their own following birth'),
        'nb_received_neonatal_resus': Property(Types.BOOL, 'If this neonate has received resuscitation'),
        'nb_encephalopathy': Property(Types.CATEGORICAL, 'None, mild encephalopathy, moderate encephalopathy, '
                                                         'severe encephalopathy',
                                      categories=['none', 'mild_enceph', 'moderate_enceph', 'severe_enceph']),
        'nb_encephalopathy_disab': Property(Types.CATEGORICAL, 'Disability associated neonatal sepsis',
                                            categories=['none', 'mild_motor_and_cog', 'mild_motor',
                                                        'moderate_motor', 'severe_motor']),
        'nb_retinopathy_prem': Property(Types.CATEGORICAL, 'Level of visual disturbance due to retinopathy of'
                                                           ' prematurity: None, mild, moderate, severe, blindness',
                                        categories=['none', 'mild', 'moderate', 'severe', 'blindness']),
        'nb_low_birth_weight_status': Property(Types.CATEGORICAL, 'extremely low birth weight (<1000g), '
                                                                  ' very low birth weight (<1500g), '
                                                                  'low birth weight (<2500g),'
                                                                  'normal birth weight (>2500g), macrosomia (>4000g)',
                                               categories=['extremely_low_birth_weight', 'very_low_birth_weight',
                                                           'low_birth_weight', 'normal_birth_weight', 'macrosomia']),
        'nb_size_for_gestational_age': Property(Types.CATEGORICAL, 'size for gestational age categories',
                                                categories=['small_for_gestational_age', 'average_for_gestational_age',
                                                            'large_for_gestational_age']),
        'nb_early_init_breastfeeding': Property(Types.BOOL, 'whether this neonate initiated breastfeeding '
                                                            'within 1 hour of birth '),
        'nb_breastfeeding_status': Property(Types.CATEGORICAL, 'How this neonate is being breastfed',
                                            categories=['none', 'non_exclusive', 'exclusive']),
        'nb_kangaroo_mother_care': Property(Types.BOOL, 'whether this neonate received kangaroo mother care following '
                                                        'birth'),
        'nb_clean_birth': Property(Types.BOOL, 'whether this neonate received clean birth practices at delivery'),
        'nb_received_cord_care': Property(Types.BOOL, 'whether this neonate received chlorhexidine cord care'),
        'nb_death_after_birth': Property(Types.BOOL, 'whether this child has died following complications after birth'),
        'nb_pnc_check': Property(Types.INT, 'Number of postnatal checks received in the postnatal period'),
    }

    def read_parameters(self, data_folder):

        parameter_dataframe = pd.read_excel(Path(self.resourcefilepath) / 'ResourceFile_NewbornOutcomes.xlsx',
                                            sheet_name='parameter_values')
        self.load_parameters_from_dataframe(parameter_dataframe)

        # For the first period (2010-2015) we use the first value in each list as a parameter
        for key, value in self.parameters.items():
            self.current_parameters[key] = self.parameters[key][0]

        # Here we map 'disability' parameters to associated DALY weights to be passed to the health burden module
        if 'HealthBurden' in self.sim.modules:
            self.parameters['nb_daly_weights'] = {
                'mild_motor_cognitive_preterm': self.sim.modules['HealthBurden'].get_daly_weight(357),
                'mild_motor_preterm': self.sim.modules['HealthBurden'].get_daly_weight(371),
                'moderate_motor_preterm': self.sim.modules['HealthBurden'].get_daly_weight(378),
                'severe_motor_preterm': self.sim.modules['HealthBurden'].get_daly_weight(383),
                # n.b. DALY weight for prematurity are separated by disability and gestation (<28wks, 28-32wks etc) but
                # the weight doesnt differ by gestation, only severity- so has been condensed here

                'mild_vision_rptb': self.sim.modules['HealthBurden'].get_daly_weight(404),
                'moderate_vision_rptb': self.sim.modules['HealthBurden'].get_daly_weight(405),
                'severe_vision_rptb': self.sim.modules['HealthBurden'].get_daly_weight(402),
                'blindness_rptb': self.sim.modules['HealthBurden'].get_daly_weight(386),

                'mild_motor_cognitive_enceph': self.sim.modules['HealthBurden'].get_daly_weight(419),
                'mild_motor_enceph': self.sim.modules['HealthBurden'].get_daly_weight(416),
                'moderate_motor_enceph': self.sim.modules['HealthBurden'].get_daly_weight(411),
                'severe_motor_enceph': self.sim.modules['HealthBurden'].get_daly_weight(410),

                'mild_motor_sepsis': self.sim.modules['HealthBurden'].get_daly_weight(431),
                'moderate_motor_sepsis': self.sim.modules['HealthBurden'].get_daly_weight(438),
                'severe_motor_sepsis': self.sim.modules['HealthBurden'].get_daly_weight(435),
                'mild_motor_cognitive_sepsis': self.sim.modules['HealthBurden'].get_daly_weight(441)}

    def initialise_population(self, population):
        df = population.props

        df.loc[df.is_alive, 'nb_is_twin'] = False
        df.loc[df.is_alive, 'nb_twin_sibling_id'] = -1
        df.loc[df.is_alive, 'nb_early_preterm'] = False
        df.loc[df.is_alive, 'nb_late_preterm'] = False
        df.loc[df.is_alive, 'nb_preterm_birth_disab'] = 'none'
        df.loc[df.is_alive, 'nb_congenital_anomaly'] = 0
        df.loc[df.is_alive, 'nb_early_onset_neonatal_sepsis'] = False
        df.loc[df.is_alive, 'nb_inj_abx_neonatal_sepsis'] = False
        df.loc[df.is_alive, 'nb_supp_care_neonatal_sepsis'] = False
        df.loc[df.is_alive, 'nb_neonatal_sepsis_disab'] = 'none'
        df.loc[df.is_alive, 'nb_preterm_respiratory_distress'] = False
        df.loc[df.is_alive, 'nb_not_breathing_at_birth'] = False
        df.loc[df.is_alive, 'nb_received_neonatal_resus'] = False
        df.loc[df.is_alive, 'nb_encephalopathy'] = 'none'
        df.loc[df.is_alive, 'nb_encephalopathy_disab'] = 'none'
        df.loc[df.is_alive, 'nb_retinopathy_prem'] = 'none'
        df.loc[df.is_alive, 'nb_low_birth_weight_status'] = 'normal_birth_weight'
        df.loc[df.is_alive, 'nb_size_for_gestational_age'] = 'average_for_gestational_age'
        df.loc[df.is_alive, 'nb_early_init_breastfeeding'] = False
        df.loc[df.is_alive, 'nb_breastfeeding_status'] = 'none'
        df.loc[df.is_alive, 'nb_kangaroo_mother_care'] = False
        df.loc[df.is_alive, 'nb_clean_birth'] = False
        df.loc[df.is_alive, 'nb_received_cord_care'] = False
        df.loc[df.is_alive, 'nb_death_after_birth'] = False
        df.loc[df.is_alive, 'nb_pnc_check'] = 0

        # We store congenital anomalies as bitset
        self.congeintal_anomalies = BitsetHandler(self.sim.population, 'nb_congenital_anomaly',
                                                  ['heart', 'limb_musc_skeletal', 'urogenital', 'digestive', 'other'])

    def initialise_simulation(self, sim):
        # Register logging event
        sim.schedule_event(NewbornOutcomesLoggingEvent(self), sim.date + DateOffset(years=1))

        # =======================Register dx_tests for complications during labour/postpartum=======================
        # As with the labour module these dx_tests represent a probability that one of the following clinical outcomes
        # will be detected by the health care worker and treatment will be initiated

        # The sensitivity parameter varies by facility type, with 'hc' meaning health centre and 'hp' meaning hospital

        dx_manager = sim.modules['HealthSystem'].dx_manager

        # Neonatal sepsis...
        dx_manager.register_dx_test(assess_neonatal_sepsis_hc=DxTest(
            property='nb_early_onset_neonatal_sepsis',
            sensitivity=self.current_parameters['sensitivity_of_assessment_of_neonatal_sepsis_hc']))
        dx_manager.register_dx_test(assess_neonatal_sepsis_hp=DxTest(
            property='nb_early_onset_neonatal_sepsis',
            sensitivity=self.current_parameters['sensitivity_of_assessment_of_neonatal_sepsis_hp']))

        # Not breathing at birth ...
        dx_manager.register_dx_test(assess_not_breathing_at_birth_hc=DxTest(
            property='nb_not_breathing_at_birth',
            sensitivity=self.current_parameters['sensitivity_of_assessment_of_ftt_hc']))
        dx_manager.register_dx_test(assess_not_breathing_at_birth_hp=DxTest(
            property='nb_not_breathing_at_birth',
            sensitivity=self.current_parameters['sensitivity_of_assessment_of_ftt_hp']))

        # Low birth weight...
        dx_manager.register_dx_test(assess_low_birth_weight_hc=DxTest(
            property='nb_low_birth_weight_status', target_categories=['extremely_low_birth_weight',
                                                                      'very_low_birth_weight',
                                                                      'low_birth_weight'],
            sensitivity=self.current_parameters['sensitivity_of_assessment_of_lbw_hc'])),
        dx_manager.register_dx_test(assess_low_birth_weight_hp=DxTest(
            property='nb_low_birth_weight_status', target_categories=['extremely_low_birth_weight',
                                                                      'very_low_birth_weight',
                                                                      'low_birth_weight'],
            sensitivity=self.current_parameters['sensitivity_of_assessment_of_lbw_hp']))

        # ======================================= LINEAR MODEL EQUATIONS ==============================================
        # All linear equations used in this module are stored within the nb_newborn_equations
        # parameter below

        params = self.current_parameters
        self.nb_linear_models = {

            # This equation is used to determine a newborns risk of early onset neonatal sepsis. Risk of early onset
            # sepsis is mitigated by a number of interventions
            'early_onset_neonatal_sepsis': LinearModel.custom(newborn_outcomes_lm.predict_early_onset_neonatal_sepsis,
                                                              parameters=params),

            # This equation is used to determine a newborns risk of encephalopathy
            'encephalopathy': LinearModel.custom(newborn_outcomes_lm.predict_encephalopathy, module=self,
                                                 parameters=params),

            # This equation is used to determine a preterm newborns risk of respiratory distress syndrome
            # (secondary to incomplete lung development)
            'rds_preterm': LinearModel.custom(newborn_outcomes_lm.predict_rds_preterm, module=self,
                                              parameters=params),

            # This equation is used to determine a newborns risk of not breathing after delivery,
            # triggering resuscitation
            'not_breathing_at_birth': LinearModel.custom(newborn_outcomes_lm.predict_not_breathing_at_birth,
                                                         parameters=params),

            # This equation is used to determine a premature newborns risk of retinopathy
            'retinopathy': LinearModel.custom(newborn_outcomes_lm.predict_retinopathy, parameters=params),

            # This equation is used to determine the probability that a the mother of a newborn, who has been delivered
            # at home, will seek care in the event that a newborn experiences complications after birth
            'care_seeking_for_complication': LinearModel.custom(
                newborn_outcomes_lm.predict_care_seeking_for_complication, parameters=params),

            # This equation is used to determine a preterm newborns risk of death due to 'complications of prematurity'
            #  not explicitly modelled here (therefore excluding sepsis, encephalopathy and RDS)
            'preterm_other_death': LinearModel.custom(
                newborn_outcomes_lm.predict_preterm_birth_other_death, parameters=params),

            # This equation is used to determine a the risk of death for a newborn who doesnt breathe at birth.
            'neonatal_respiratory_depression_death': LinearModel.custom(
                newborn_outcomes_lm.predict_not_breathing_at_birth_death, parameters=params),

            # This equations is used to determine the risk of death for encephalopathic newborns.
            'encephalopathy_death': LinearModel.custom(
                newborn_outcomes_lm.predict_enceph_death, parameters=params),

            # This equation is used to determine a newborns risk of death from sepsis
            'early_onset_neonatal_sepsis_death': LinearModel.custom(
                newborn_outcomes_lm.predict_neonatal_sepsis_death, parameters=params),

            # This equation is used to determine a preterm newborns risk of death due to respiratory distress syndrome
            'respiratory_distress_syndrome_death': LinearModel.custom(
                newborn_outcomes_lm.predict_respiratory_distress_death, parameters=params)}

        # Finally we add this warning note to document that HIV testing will not occur if the correct module isnt
        # registered
        if 'Hiv' not in self.sim.modules:
            logger.warning(key='message', data='HIV module is not registered in this simulation run and therefore HIV '
                                               'testing will not happen in newborn care')

    def eval(self, eq, person_id):
        """
        This function compares the result of a specific linear equation with a random draw providing
        a boolean for the outcome under examination. For equations that require external variables,
        they are also defined here
        :param eq: The linear model equation being evaluated
        :param person_id: person_id
        :return: BOOL outcome
        """
        df = self.sim.population.props
        nci = self.newborn_care_info
        person = df.loc[[person_id]]

        # Here we define all the possible external variables used in the linear model
        steroid_status = nci[person_id]['corticosteroids_given']
        abx_for_prom = nci[person_id]['abx_for_prom_given']

        if nci[person_id]['maternal_chorio']:
            chorio = True
        else:
            chorio = False

        # We return a BOOLEAN
        return self.rng.random_sample(size=1) < eq.predict(person,
                                                           received_corticosteroids=steroid_status,
                                                           received_abx_for_prom=abx_for_prom,
                                                           maternal_chorioamnionitis=chorio,
                                                           )[person_id]

    # ========================================= OUTCOME FUNCTIONS  ===================================================
    # These functions are called within the on_birth function or
    # HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendant depending on location of delivery. Generally they
    # output an individuals probability of an outcome (complication, disability, death) and make the relevant changes
    # to the data frame

    def apply_risk_of_congenital_anomaly(self, child_id):
        """
        This function determines if a neonate has been born with one of the common congenital anomalies.
        It is called during the on_birth function.
        :param child_id: child_id
        """
        params = self.current_parameters

        if self.rng.random_sample() < params['prob_congenital_heart_anomaly']:
            self.congeintal_anomalies.set(child_id, 'heart')
            logger.info(key='newborn_complication', data={'newborn': child_id,
                                                          'type': 'congenital_heart_anomaly'})

        if self.rng.random_sample() < params['prob_limb_musc_skeletal_anomaly']:
            self.congeintal_anomalies.set(child_id, 'limb_musc_skeletal')
            logger.info(key='newborn_complication', data={'newborn': child_id,
                                                          'type': 'limb_or_musculoskeletal_anomaly'})

        if self.rng.random_sample() < params['prob_urogenital_anomaly']:
            self.congeintal_anomalies.set(child_id, 'urogenital')
            logger.info(key='newborn_complication', data={'newborn': child_id,
                                                          'type': 'urogenital_anomaly'})

        if self.rng.random_sample() < params['prob_digestive_anomaly']:
            self.congeintal_anomalies.set(child_id, 'digestive')
            logger.info(key='newborn_complication', data={'newborn': child_id,
                                                          'type': 'digestive_anomaly'})

        if self.rng.random_sample() < params['prob_other_anomaly']:
            self.congeintal_anomalies.set(child_id, 'other')
            logger.info(key='newborn_complication', data={'newborn': child_id,
                                                          'type': 'other_anomaly'})

    def apply_risk_of_neonatal_infection_and_sepsis(self, child_id):
        """
        This function uses the linear model to determines if a neonate will develop early onset neonatal sepsis.
        It is called during the on_birth function or during HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendant
        dependent on delivery setting.
        :param child_id: child_id
        """
        df = self.sim.population.props

        # The linear model calculates the individuals probability of early_onset_neonatal_sepsis
        if self.eval(self.nb_linear_models['early_onset_neonatal_sepsis'], child_id):
            df.at[child_id, 'nb_early_onset_neonatal_sepsis'] = True

            logger.info(key='newborn_complication', data={'newborn': child_id,
                                                          'type': 'early_onset_sepsis'})

    def apply_risk_of_encephalopathy(self, child_id, timing):
        """
        This function determines if a neonate will develop neonatal encephalopathy on birth or after birth
        (if they were not breathing), at what severity, and makes the appropriate changes to the data frame.
         It is called during the on_birth function or  during HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendant
         dependent on delivery setting.
        :param child_id: child_id
        :param timing: on_birth or after_birth
        """
        params = self.current_parameters
        df = self.sim.population.props

        # We use a linear model equation to determine risk of encephalopathy on birth
        if timing == 'on_birth':
            result = self.eval(self.nb_linear_models['encephalopathy'], child_id)
        else:
            # Or, if we are applying risk to a non-encephalopathic newborn who was not breathing at birth
            result = self.rng.random_sample() < params['prob_enceph_no_resus']

        if result:
            # For a newborn who is encephalopathic we then set the severity using a weighted probability derived from
            # the prevalence of severity of encephalopathy in the encephalopathic population
            severity_enceph = self.rng.choice(('mild', 'moderate', 'severe'), p=params['prob_enceph_severity'])

            if severity_enceph == 'mild':
                df.at[child_id, 'nb_encephalopathy'] = 'mild_enceph'
            elif severity_enceph == 'moderate':
                df.at[child_id, 'nb_encephalopathy'] = 'moderate_enceph'
            else:
                df.at[child_id, 'nb_encephalopathy'] = 'severe_enceph'

            logger.info(key='newborn_complication', data={'newborn': child_id,
                                                          'type': f'{df.at[child_id, "nb_encephalopathy"]}'})

            # Check all encephalopathy cases receive a grade
            assert df.at[child_id, 'nb_encephalopathy'] != 'none'

    def apply_risk_of_preterm_respiratory_distress_syndrome(self, child_id):
        """
        This function uses the linear model to determine if a preterm neonate will develop respiratory distress
        syndrome. It is called during the on_birth function or during
        HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendant
        dependent on delivery setting.
        :param child_id: child_id
        """
        df = self.sim.population.props
        params = self.current_parameters
        child = df.loc[child_id]

        # Ensure only preterm infants have risk of RDS applied
        assert child.nb_early_preterm or child.nb_late_preterm

        # Use the linear model to calculate individual risk and make changes
        if self.eval(self.nb_linear_models['rds_preterm'], child_id):
            df.at[child_id, 'nb_preterm_respiratory_distress'] = True

            logger.info(key='newborn_complication', data={'newborn': child_id,
                                                          'type': 'respiratory_distress_syndrome'})

    def apply_risk_of_not_breathing_at_birth(self, child_id):
        """
        This function uses the linear model to determines if a neonate will not sufficiently initiate breathing at birth
         and makes the appropriate changes to the data frame. It is called during the on_birth function or
        during HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendant dependent on delivery setting.
        :param child_id: child_id
        """
        df = self.sim.population.props

        # We assume all newborns with encephalopathy and respiratory distress syndrome will require some form of
        # resuscitation and will not be effectively breathing at birth
        if df.at[child_id, 'nb_encephalopathy'] != 'none' or df.at[child_id, 'nb_preterm_respiratory_distress']:
            df.at[child_id, 'nb_not_breathing_at_birth'] = True

        # Otherwise we use the linear model to calculate risk of inadequate breathing due to other causes not
        # explicitly modelled
        elif self.eval(self.nb_linear_models['not_breathing_at_birth'], child_id):
            df.at[child_id, 'nb_not_breathing_at_birth'] = True

            logger.info(key='newborn_complication', data={'newborn': child_id,
                                                          'type': 'not_breathing_at_birth'})

    def scheduled_week_one_postnatal_event(self, individual_id):
        """
        This function schedules PostnatalWeekOneNeonatalEvent within the Postnatal Supervisor module. Date on which the
         newborn attends is randomly spread across the first week of life
        :param individual_id: individual_id
        """
        nci = self.newborn_care_info
        df = self.sim.population.props
        params = self.current_parameters

        # Only run this function on newborns are yet to reach the postnatal period
        if nci[individual_id]['passed_through_week_one']:
            return

        days_post_birth_td = self.sim.date - df.at[individual_id, 'date_of_birth']
        days_post_birth_int = int(days_post_birth_td / np.timedelta64(1, 'D'))

        # Ensure that these newborns are less than one week old and scheduled the event accordingly
        assert days_post_birth_int < 6

        day_for_event = int(self.rng.choice([2, 3, 4, 5, 6], p=params['prob_day_reaches_week_one_event']))

        # Ensure no newborns go to this event after week 1
        if day_for_event + days_post_birth_int > 6:
            day_for_event = 1

        self.sim.schedule_event(
            PostnatalWeekOneNeonatalEvent(self.sim.modules['PostnatalSupervisor'], individual_id),
            self.sim.date + DateOffset(days=day_for_event))

    def set_death_status(self, individual_id):
        """
        This function cycles through each complication of which a newborn may die, if the newborn has experienced one or
         more of these complication it calculates overall risk of death and then the probability that each complication
         was the primary cause of death. This information is logged and the death event is scheduled.
        :param individual_id: individual_id
        """

        df = self.sim.population.props
        nci = self.newborn_care_info
        mni = self.sim.modules['PregnancySupervisor'].mother_and_newborn_info
        params = self.current_parameters
        child = df.loc[individual_id]

        logger.debug(key='msg', data=f'set_death_status for newborn {individual_id}')

        # First we create a list of possible causes of death for each newborn according to the complications they have
        # experienced since birth
        causes = list()

        if child.nb_early_onset_neonatal_sepsis or child.pn_sepsis_early_neonatal:
            causes.append('early_onset_neonatal_sepsis')

        if child.pn_sepsis_late_neonatal:
            causes.append('late_onset_neonatal_sepsis')

        if not nci[individual_id]['passed_through_week_one']:

            if child.nb_encephalopathy == 'mild_enceph' or child.nb_encephalopathy == 'moderate_enceph' or \
               child.nb_encephalopathy == 'severe_enceph':
                causes.append('encephalopathy')

            if child.nb_not_breathing_at_birth and (child.nb_encephalopathy == 'none') and \
               (~child.nb_preterm_respiratory_distress):
                causes.append('neonatal_respiratory_depression')

            if child.nb_early_preterm or child.nb_late_preterm:
                causes.append('preterm_other')

            if child.nb_preterm_respiratory_distress:
                causes.append('respiratory_distress_syndrome')

            if self.congeintal_anomalies.has_all(individual_id, 'heart'):
                causes.append('congenital_heart_anomaly')
            if self.congeintal_anomalies.has_all(individual_id, 'limb_musc_skeletal'):
                causes.append('limb_or_musculoskeletal_anomaly')
            if self.congeintal_anomalies.has_all(individual_id, 'urogenital'):
                causes.append('urogenital_anomaly')
            if self.congeintal_anomalies.has_all(individual_id, 'digestive'):
                causes.append('digestive_anomaly')
            if self.congeintal_anomalies.has_all(individual_id, 'other'):
                causes.append('other_anomaly')

        # Using this list we predict the probability of death from each complications associated linear model for death
        # and store this in a dictionary
        if causes:
            risks = dict()

            for cause in causes:
                if f'{cause}_death' in self.nb_linear_models.keys():
                    risk = {f'{cause}': self.nb_linear_models[f'{cause}_death'].predict(
                        df.loc[[individual_id]])[individual_id]}
                else:
                    risk = {f'{cause}': params[f'cfr_{cause}']}

                risks.update(risk)

            # Next calculate the overall risk of death from one or more complications
            result = 1

            for cause in risks:
                result *= (1 - risks[cause])

            # If random draw is less that the total risk of death, she will die and the primary cause is then determined
            if self.rng.random_sample() < (1 - result):
                logger.debug(key='msg', data=f'Newborns {individual_id} has died following birth ')

                df.at[individual_id, 'nb_death_after_birth'] = True

                denominator = sum(risks.values())

                probs = list()

                # Cycle over each cause in the dictionary and divide by the sum of the probabilities
                for cause in risks:
                    risks[cause] = risks[cause] / denominator
                    probs.append(risks[cause])

                # Log the death (eventually this can be removed)
                cause_of_death = self.rng.choice(causes, p=probs)

                if cause_of_death == 'preterm_other':

                    # If the death is associated with prematurity we scatter those deaths across the first 2 weeks
                    random_draw = self.rng.choice([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
                                                  p=params['prob_preterm_death_by_day'])
                    death_date = self.sim.date + DateOffset(days=int(random_draw))
                else:
                    death_date = self.sim.date

                if individual_id in nci:
                    del nci[individual_id]

                self.sim.schedule_event(demography.InstantaneousDeath(self, individual_id,
                                                                      cause=f'{cause_of_death}'), death_date)
            # Reset variables
            else:
                df.at[individual_id, 'nb_early_onset_neonatal_sepsis'] = False
                df.at[individual_id, 'pn_sepsis_early_neonatal'] = False
                df.at[individual_id, 'pn_sepsis_late_neonatal'] = False

        # Finally we schedule the postnatal week one event
        if individual_id in nci:
            if not nci[individual_id]['passed_through_week_one']:
                self.scheduled_week_one_postnatal_event(individual_id)

        # We now delete the MNI dictionary for mothers who have died in labour but their children have survived,
        # this is done here as we use variables from the mni as predictors in some of the above equations
        mother_id = df.loc[individual_id, 'mother_id']
        if not df.at[mother_id, 'is_alive']:
            if ~df.at[mother_id, 'ps_multiple_pregnancy'] or (df.at[mother_id, 'ps_multiple_pregnancy'] and
                                                                  (mni[mother_id]['twin_count'] == 2)):
                if mother_id in mni:
                    del mni[mother_id]

    def set_disability_status(self, individual_id):
        """
        This function cycles through each complication experience by a newborn during birth/neonatal period and
        determines if this newborn will experience long term developmental impairment due to said complication. It is
        called at the end of the neonatal period by the PostnatalSupervisor event for survivors of the neonatal period.
        :param individual_id: individual_id
        """
        nci = self.newborn_care_info
        params = self.current_parameters
        df = self.sim.population.props
        child = df.loc[individual_id]

        logger.debug(key='message', data=f'Child {individual_id} will have now their DALYs calculated following '
                                         f'complications after birth')

        choice = self.rng.choice

        if nci[individual_id]['ga_at_birth'] < 32:
            if self.rng.random_sample() < params['prob_mild_disability_preterm_<32weeks']:
                df.at[individual_id, 'nb_preterm_birth_disab'] = choice(['mild_motor_and_cog', 'mild_motor'])

            elif self.rng.random_sample() < params['prob_mod_severe_disability_preterm_<32weeks']:
                df.at[individual_id, 'nb_preterm_birth_disab'] = choice(['moderate_motor', 'severe_motor'])

        elif 32 <= nci[individual_id]['ga_at_birth'] < 37:
            if self.rng.random_sample() < params['prob_mild_disability_preterm_32_36weeks']:
                df.at[individual_id, 'nb_preterm_birth_disab'] = choice(['mild_motor_and_cog', 'mild_motor'])

            elif self.rng.random_sample() < params['prob_mod_severe_disability_preterm_32_36weeks']:
                df.at[individual_id, 'nb_preterm_birth_disab'] = choice(['moderate_motor', 'severe_motor'])

        if child.nb_encephalopathy != 'none':
            if self.rng.random_sample() < params['prob_mild_impairment_post_enceph']:
                df.at[individual_id, 'nb_encephalopathy_disab'] = choice(['mild_motor_and_cog', 'mild_motor'])

            elif self.rng.random_sample() < params['prob_mod_severe_impairment_post_enceph']:
                df.at[individual_id, 'nb_encephalopathy_disab'] = choice(['moderate_motor', 'severe_motor'])

        # n.b. no data data on sepsis long term outcomes, using encephalopathy data as a proxy for now...
        if child.nb_early_onset_neonatal_sepsis or nci[individual_id]['sepsis_postnatal']:
            if self.rng.random_sample() < params['prob_mild_impairment_post_enceph']:
                df.at[individual_id, 'nb_neonatal_sepsis_disab'] = choice(['mild_motor_and_cog', 'mild_motor'])

            elif self.rng.random_sample() < params['prob_mod_severe_impairment_post_enceph']:
                df.at[individual_id, 'nb_neonatal_sepsis_disab'] = choice(['moderate_motor', 'severe_motor'])

            # TODO: Add simplified disability for congenital anomalies

        del nci[individual_id]

    # ======================================== HSI INTERVENTION FUNCTIONS =============================================
    # These functions are called by HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendant and broadly represent
    # interventions/packages of interventions to manage the main complications in the module

    def essential_newborn_care(self, hsi_event):
        """
        This function contains interventions delivered as part of 'essential newborn care'. These include clean birth
        practices, cord care, vitamin k and eye care
        :param hsi_event:  The HSI event in which this function is called
        (HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendant)
        """
        df = self.sim.population.props
        nci = self.newborn_care_info
        person_id = hsi_event.target
        consumables = self.sim.modules['HealthSystem'].parameters['Consumables']

        # -------------------------------------- CHLORHEXIDINE CORD CARE ----------------------------------------------
        # Next we determine if cord care with chlorhexidine is applied (consumables are counted during labour)
        df.at[person_id, 'nb_received_cord_care'] = True

        # ---------------------------------- VITAMIN D AND EYE CARE -----------------------------------------------
        # We define the consumables
        item_code_tetracycline = pd.unique(
            consumables.loc[consumables['Items'] == 'Tetracycline eye ointment, 1 %, tube 5 mg', 'Item_Code'])[0]
        item_code_vit_k = pd.unique(
            consumables.loc[consumables['Items'] == 'vitamin K1  (phytomenadione) 1 mg/ml, 1 ml, inj._100_IDA',
                                                    'Item_Code'])[0]
        item_code_vit_k_syringe = pd.unique(
            consumables.loc[consumables['Items'] == 'Syringe, needle + swab', 'Item_Code'])[0]

        consumables_vit_k_and_eye_care = {
            'Intervention_Package_Code': {},
            'Item_Code': {item_code_tetracycline: 1, item_code_vit_k: 1, item_code_vit_k_syringe: 1}}

        outcome_of_request_for_consumables = self.sim.modules['HealthSystem'].request_consumables(
            hsi_event=hsi_event, cons_req_as_footprint=consumables_vit_k_and_eye_care)

        # If they are available the intervention is delivered, there is limited evidence of the effect of these
        # interventions so currently we are just mapping the consumables
        if outcome_of_request_for_consumables['Item_Code'][item_code_tetracycline]:
            logger.debug(key='message', data=f'Neonate {person_id} has received tetracycline eye drops following a '
                                             f'facility delivery')
            nci[person_id]['tetra_eye_d'] = True

        else:
            logger.debug(key='message', data='This facility has no tetracycline and therefore was not given')

        # This process is repeated for vitamin K
        if outcome_of_request_for_consumables['Item_Code'][item_code_vit_k]:

            logger.debug(key='message', data=f'Neonate {person_id} has received vitamin k prophylaxis following'
                                             f' a facility delivery')

            nci[person_id]['vit_k'] = True

        else:
            logger.debug(key='message', data='This facility has no vitamin K and therefore was not given')

    def breast_feeding(self, person_id, birth_setting):
        """
        This function is used to set breastfeeding status for newborns. It schedules the BreastfeedingStatusUpdateEvent
        for breastfed newborns. It is called during the
        on_birth function or during HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendant dependent on delivery
        setting.
        :param person_id: person_id
        :param birth_setting: hf (health facility) or hb (home birth)
        """
        df = self.sim.population.props
        params = self.current_parameters
        mni = self.sim.modules['PregnancySupervisor'].mother_and_newborn_info
        mother_id = df.at[person_id, 'mother_id']

        # We determine breastfeeding for non-twins or first born twins (second born twins will match first born for
        # breastfeeding type)
        if ~df.at[person_id, 'nb_is_twin'] or (df.at[mother_id, 'ps_multiple_pregnancy'] and
                                               mni[mother_id]['twin_count'] == 1):

            # First we determine the 'type' of breastfeeding this newborn will receive
            random_draw = self.rng.choice(('none', 'non_exclusive', 'exclusive'), p=params['prob_breastfeeding_type'])
            df.at[person_id, 'nb_breastfeeding_status'] = random_draw
            # Log that information for debugging
            if random_draw == 'none':
                logger.debug(key='message', data=f'Neonate {person_id} will not be breastfed')
            else:
                logger.debug(key='message', data=f'Neonate {person_id} will be {random_draw}ly breastfed up to 6 '
                                                 f'months')

            # For newborns that are breastfed, we apply a probability that breastfeeding was initiated within one hour.
            # This varies between home births and facility deliveries
            if df.at[person_id, 'nb_breastfeeding_status'] != 'none':

                if self.rng.random_sample() < params[f'prob_early_breastfeeding_{birth_setting}']:
                    df.at[person_id, 'nb_early_init_breastfeeding'] = True

                    logger.debug(key='message', data=f'Neonate {person_id} has started breastfeeding within 1 hour of '
                                                     f'birth')
                else:
                    logger.debug(key='message', data=f'Neonate {person_id} did not start breastfeeding within 1 hour '
                                                     f'of birth')
            # We store the breastfeeding information of the first twin in a twin pair to ensure twins have the same
            # breastfeeding status
            if df.at[mother_id, 'ps_multiple_pregnancy'] and mni[mother_id]['twin_count'] == 1:
                mni[mother_id]['bf_status_twin_one'] = random_draw
                mni[mother_id]['eibf_status_twin_one'] = df.at[person_id, 'nb_early_init_breastfeeding']

        # Here we set the breastfeeding status of any second born twins
        elif df.at[mother_id, 'ps_multiple_pregnancy'] and mni[mother_id]['twin_count'] == 2:
            df.at[person_id, 'nb_breastfeeding_status'] = mni[mother_id]['bf_status_twin_one']
            df.at[person_id, 'nb_early_init_breastfeeding'] = mni[mother_id]['eibf_status_twin_one']

        if df.at[person_id, 'nb_breastfeeding_status'] != 'none':
            # For breastfed neonates we schedule a future event where breastfeeding status is updated
            self.sim.schedule_event(BreastfeedingStatusUpdateEventSixMonths(self, person_id),
                                    self.sim.date + DateOffset(months=6))

    def kangaroo_mother_care(self, hsi_event, facility_type):
        """
        This function manages the diagnosis and treatment of low birth weight neonates who have
        delivered in a facility. It is called by the HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendant.
        The intervention delivered is Kangaroo Mother Care (KMC) which includes skin-to-skin nursing and encouragement
        of frequent and exclusive breastfeeding
        :param hsi_event: The HSI event in which this function is called
        (HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendant)
        :param facility_type: health centre (hc) or hospital (hp)
        """
        df = self.sim.population.props
        person_id = hsi_event.target

        # We use the dx_manager to determine if a newborn who is low birth weight is correctly identified and treated
        if self.sim.modules['HealthSystem'].dx_manager.run_dx_test(
                dx_tests_to_run=f'assess_low_birth_weight_{facility_type}', hsi_event=hsi_event):

            # Store treatment as a property of the newborn used to apply treatment effect
            df.at[person_id, 'nb_kangaroo_mother_care'] = True

            logger.debug(key='message', data=f'Neonate {person_id} has been correctly identified as being low birth '
                                             f'weight, and kangaroo mother care has been initiated')

    def immunisations(self, child_id):
        """
        This is a placeholder. Will house/call immunisation events for newborns
        :param child_id: child_id
        """
        pass

    def hiv_screening_for_at_risk_newborns(self, child_id):
        """
        This function schedules immediate HIV screening for newborns of mothers who are HIV positive. Additional
         treatment is managed within the HIV module
        :param child_id: child_id
        """
        df = self.sim.population.props
        child_id = int(child_id)
        # mother_id = df.at[child_id, 'mother_id']

        if 'Hiv' in self.sim.modules:
            if ~df.at[child_id, 'hv_diagnosed']:  # and df.at[mother_id, 'hv_diagnosed']:

                if df.at[child_id, 'nb_pnc_check'] == 1:
                    logger.debug(key='message', data=f'Neonate {child_id} is receiving HIV screening after birth')
                    for days in 0, 41:
                        self.sim.modules['HealthSystem'].schedule_hsi_event(
                            HSI_Hiv_TestAndRefer(person_id=child_id, module=self.sim.modules['Hiv']),
                            topen=self.sim.date + pd.DateOffset(days=days),
                            tclose=None,
                            priority=0
                        )

    def assessment_and_initiation_of_neonatal_resus(self, hsi_event, facility_type):
        """
        This function manages the diagnosis of failure to transition/encephalopathy and the administration of neonatal
        resuscitation for neonates delivered in a facility. It is called by the HSI_NewbornOutcomes_CareOfTheNewborn
        BySkilledAttendant.
        :param hsi_event: The HSI event in which this function is called
        (HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendant)
        :param facility_type: health centre (hc) or hospital (hp)
        """
        df = self.sim.population.props
        person_id = hsi_event.target
        consumables = self.sim.modules['HealthSystem'].parameters['Consumables']

        # Required consumables are defined
        pkg_code_resus = pd.unique(consumables.loc[
                                       consumables['Intervention_Pkg'] == 'Neonatal resuscitation (institutional)',
                                       'Intervention_Pkg_Code'])[0]

        all_available = hsi_event.get_all_consumables(
            pkg_codes=[pkg_code_resus])

        # Use the dx_manager to determine if staff will correctly identify this neonate will require resuscitation
        if self.sim.modules['HealthSystem'].dx_manager.run_dx_test(
           dx_tests_to_run=f'assess_not_breathing_at_birth_{facility_type}', hsi_event=hsi_event):

            # Then, if the consumables are available,resuscitation is started. We assume this is delayed in
            # deliveries that are not attended
            if all_available:
                df.at[person_id, 'nb_received_neonatal_resus'] = True

            else:
                self.apply_risk_of_encephalopathy(person_id, timing='after_birth')

    def assessment_and_treatment_newborn_sepsis(self, hsi_event, facility_type):
        """
        This function manages the treatment of early onset neonatal sepsis for neonates delivered in a facility.
         It is called by the
        HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendant. Treatment for sepsis includes either injectable
         antibiotics or full supportive care (antibiotics, fluids, oxygen etc) and varies between facility level.
        :param hsi_event: The HSI event in which this function is called
        (HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendant)
        :param facility_type: health centre (hc) or hospital (hp)
        """
        df = self.sim.population.props
        person_id = int(hsi_event.target)
        consumables = self.sim.modules['HealthSystem'].parameters['Consumables']

        # We assume that only hospitals are able to deliver full supportive care for neonatal sepsis, full supportive
        # care evokes a stronger treatment effect than injectable antibiotics alone

        if facility_type == 'hp':
            # Define the consumables
            pkg_code_sep = pd.unique(consumables.loc[
                                     consumables['Intervention_Pkg'] == 'Newborn sepsis - full supportive care',
                                     'Intervention_Pkg_Code'])[0]

            all_available = hsi_event.get_all_consumables(
                pkg_codes=[pkg_code_sep])

            # Use the dx_manager to determine if staff will correctly identify this neonate will treatment for sepsis
            if self.sim.modules['HealthSystem'].dx_manager.run_dx_test(
                 dx_tests_to_run=f'assess_neonatal_sepsis_{facility_type}', hsi_event=hsi_event) or \
                df.at[person_id, 'pn_sepsis_late_neonatal'] or df.at[person_id, 'pn_sepsis_early_neonatal']:

                # Then, if the consumables are available, treatment for sepsis is delivered
                if all_available:
                    df.at[person_id, 'nb_supp_care_neonatal_sepsis'] = True

        # The same pattern is then followed for health centre care
        elif facility_type == 'hc':
            item_code_iv_penicillin = pd.unique(
                consumables.loc[consumables['Items'] == 'Benzylpenicillin 1g (1MU), PFR_Each_CMST', 'Item_Code'])[0]
            item_code_iv_gentamicin = pd.unique(
                consumables.loc[consumables['Items'] == 'Gentamicin 40mg/ml, 2ml_each_CMST', 'Item_Code'])[0]
            item_code_giving_set = pd.unique(consumables.loc[consumables['Items'] == 'IV giving/infusion set, with '
                                                                                     'needle',
                                                                                     'Item_Code'])[0]
            # todo: add other required consumables
            consumables_inj_abx_sepsis = {
                'Intervention_Package_Code': {},
                'Item_Code': {item_code_iv_penicillin: 1, item_code_iv_gentamicin: 1,
                              item_code_giving_set: 1}}

            outcome_of_request_for_consumables = self.sim.modules['HealthSystem'].request_consumables(
                hsi_event=hsi_event, cons_req_as_footprint=consumables_inj_abx_sepsis)

            if self.sim.modules['HealthSystem'].dx_manager.run_dx_test(
               dx_tests_to_run=f'assess_neonatal_sepsis_{facility_type}', hsi_event=hsi_event) or \
                df.at[person_id, 'pn_sepsis_late_neonatal'] or df.at[person_id, 'pn_sepsis_early_neonatal']:

                if (outcome_of_request_for_consumables['Item_Code'][item_code_iv_penicillin]) and \
                   (outcome_of_request_for_consumables['Item_Code'][item_code_iv_gentamicin]):

                    df.at[person_id, 'nb_inj_abx_neonatal_sepsis'] = True

    def link_twins(self, child_one, child_two, mother_id):
        """
        This function links twin pairs via sibling IDs and is called by the BirthEvent in the Labour module
        :param child_one: individual_id of the first born child in a twin pair
        :param child_two: individual_id of the second born child in a twin pair
        :param mother_id: individual_id of the mother of the twin pair
        """
        df = self.sim.population.props

        df.at[child_one, 'nb_twin_sibling_id'] = child_two
        df.at[child_two, 'nb_twin_sibling_id'] = child_one
        df.at[mother_id, 'ps_multiple_pregnancy'] = False

        # and log the twin pair
        twin_birth = {'twin_1_id': child_one,
                      'twin_2_id': child_two,
                      'mother_id': mother_id,
                      'date_of_delivery': self.sim.date}

        logger.info(key='twin_birth', data=twin_birth, description='A record of each birth of twin pairs')

        # Finally we log the second live birth and add another to the womans parity
        df.at[mother_id, 'la_parity'] += 1

        #todo: remove?
        logger.info(key='live_birth', data={'mother': mother_id, 'child': child_two})

    def schedule_pnc(self, child_id):
        params = self.current_parameters
        df = self.sim.population.props
        mother_id = df.at[child_id, 'mother_id']
        m = self.sim.modules['PregnancySupervisor'].mother_and_newborn_info[mother_id]
        nci = self.newborn_care_info

        timing = self.rng.choice(['<48', '>48'], p=params['prob_timings_pnc_newborns'])

        if (timing == '<48') or (m['pnc_twin_one'] == 'early'):
            nci[child_id]['will_receive_pnc'] = 'early'

            if df.at[mother_id, 'ps_multiple_pregnancy'] and (m['twin_count'] == 1):
                m['pnc_twin_one'] = 'early'

            early_event = HSI_NewbornOutcomes_ReceivesPostnatalCheck(
                module=self, person_id=child_id, facility_level_of_this_hsi=1)

            self.sim.modules['HealthSystem'].schedule_hsi_event(
                early_event, priority=0,
                topen=self.sim.date,
                tclose=None)

        else:
            nci[child_id]['will_receive_pnc'] = 'late'

    def on_birth(self, mother_id, child_id):
        """The on_birth function of this module sets key properties of all newborns, including prematurity
        status and schedules functions to set weight and size. For newborns delivered at home it determines if they will
        experience complications following birth (early onset sepsis, encephalopathy, failure to transition) and if
        these complications will lead to death or disability .For newborns delivered in facility it schedules
        HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendant which represents the care newborns should receive
        after being delivered in a facility.
        :param mother_id: mother_id
        :param child_id: child_id
        """
        df = self.sim.population.props
        params = self.current_parameters
        nci = self.newborn_care_info

        self.sim.modules['Labour'].further_on_birth_labour(mother_id, child_id)

        # We check that the baby has survived labour and has been delivered (even if the mother did not survive)
        if (df.at[mother_id, 'is_alive'] and not df.at[mother_id, 'la_intrapartum_still_birth']) or \
           (not df.at[mother_id, 'is_alive'] and not df.at[mother_id, 'la_intrapartum_still_birth']):
            mni = self.sim.modules['PregnancySupervisor'].mother_and_newborn_info
            m = mni[mother_id]

        if df.at[mother_id, 'ps_multiple_pregnancy'] and m['twin_count'] == 0:
            df.at[child_id, 'nb_is_twin'] = True
            m['twin_count'] = 1

        elif df.at[mother_id, 'ps_multiple_pregnancy'] and (m['twin_count'] == 1):
            df.at[child_id, 'nb_is_twin'] = True
            m['twin_count'] = 2

        elif ~df.at[mother_id, 'ps_multiple_pregnancy']:
            df.at[child_id, 'nb_is_twin'] = False
            df.at[child_id, 'nb_twin_sibling_id'] = -1

        df.at[child_id, 'nb_early_preterm'] = False
        df.at[child_id, 'nb_late_preterm'] = False
        df.at[child_id, 'nb_preterm_birth_disab'] = 'none'
        df.at[child_id, 'nb_congenital_anomaly'] = 0
        df.at[child_id, 'nb_early_onset_neonatal_sepsis'] = False
        df.at[child_id, 'nb_inj_abx_neonatal_sepsis'] = False
        df.at[child_id, 'nb_supp_care_neonatal_sepsis'] = False
        df.at[child_id, 'nb_neonatal_sepsis_disab'] = 'none'
        df.at[child_id, 'nb_preterm_respiratory_distress'] = False
        df.at[child_id, 'nb_not_breathing_at_birth'] = False
        df.at[child_id, 'nb_received_neonatal_resus'] = False
        df.at[child_id, 'nb_encephalopathy'] = 'none'
        df.at[child_id, 'nb_encephalopathy_disab'] = 'none'
        df.at[child_id, 'nb_retinopathy_prem'] = 'none'

        df.at[child_id, 'nb_low_birth_weight_status'] = mni[mother_id]['birth_weight']

        # todo: testing replace
        if (df.at[child_id, 'nb_low_birth_weight_status'] == 'low_birth_weight') or\
            (df.at[child_id, 'nb_low_birth_weight_status'] == 'very_low_birth_weight') or\
            (df.at[child_id, 'nb_low_birth_weight_status'] == 'extremely_low_birth_weight'):
            logger.info(key='newborn_complication', data={'newborn': child_id, 'type': 'low_birth_weight'})

        elif df.at[child_id, 'nb_low_birth_weight_status'] == 'macrosomia':
            logger.info(key='newborn_complication', data={'newborn': child_id, 'type': 'macrosomia'})

        #if df.at[child_id, 'nb_low_birth_weight_status'] != 'normal_birth_weight':
        #    if df.at[child_id, 'nb_low_birth_weight_status'] == 'macrosomia':
        #        logger.info(key='newborn_complication', data={'newborn': child_id, 'type': 'macrosomia'})
        #    else:
        #        logger.info(key='newborn_complication', data={'newborn': child_id, 'type': 'low_birth_weight'})

        df.at[child_id, 'nb_size_for_gestational_age'] = mni[mother_id]['birth_size']
        if df.at[child_id, 'nb_size_for_gestational_age'] == 'small_for_gestational_age':
            logger.info(key='newborn_complication', data={'newborn': child_id, 'type': 'small_for_gestational_age'})

        df.at[child_id, 'nb_early_init_breastfeeding'] = False
        df.at[child_id, 'nb_breastfeeding_status'] = 'none'
        df.at[child_id, 'nb_kangaroo_mother_care'] = False
        df.at[child_id, 'nb_clean_birth'] = False
        df.at[child_id, 'nb_received_cord_care'] = False
        df.at[child_id, 'nb_death_after_birth'] = False
        df.at[child_id, 'nb_pnc_check'] = 0

        # 'Category' of prematurity (early/late) is stored as a temporary property of the mother via the MNI dictionary
        # generated in labour (this is because some interventions delivered to the mother are based on prematurity)

        # We now store a newborns 'category of prematurity' within the main data frame
        if m['labour_state'] == 'early_preterm_labour':
            df.at[child_id, 'nb_early_preterm'] = True

        if m['labour_state'] == 'late_preterm_labour':
            df.at[child_id, 'nb_late_preterm'] = True

        # Check no children born at term or postterm women are incorrectly categorised as preterm
        if m['labour_state'] == 'term_labour':
            assert ~df.at[child_id, 'nb_early_preterm']
            assert ~df.at[child_id, 'nb_late_preterm']
        if m['labour_state'] == 'postterm_labour':
            assert ~df.at[child_id, 'nb_early_preterm']
            assert ~df.at[child_id, 'nb_late_preterm']

        if df.at[child_id, 'is_alive']:

            #  Next we populate the newborn info dictionary with relevant parameters
            nci[child_id] = {'ga_at_birth': int(df.at[mother_id, 'ps_gestational_age_in_weeks']),
                             'maternal_chorio': mni[mother_id]['chorio_in_preg'],
                             'maternal_gest_diab': df.at[mother_id, 'ps_gest_diab'],
                             'vit_k': False,
                             'tetra_eye_d': False,
                             'proph_abx': False,
                             'abx_for_prom_given': mni[mother_id]['abx_for_prom_given'],
                             'corticosteroids_given': mni[mother_id]['corticosteroids_given'],
                             'delivery_setting': mni[mother_id]['delivery_setting'],
                             'cause_of_death_after_birth': [],
                             'sepsis_postnatal': False,
                             'passed_through_week_one': False,
                             'will_receive_pnc': 'none'}

            if mni[mother_id]['clean_birth_practices']:
                df.at[child_id, 'nb_clean_birth'] = True

            # Check these variables are not unassigned
            assert nci[child_id]['delivery_setting'] != 'none'

            # --------------------------------------- Breastfeeding -------------------------------------------------
            # Check see if this newborn will start breastfeeding
            if m['delivery_setting'] == 'home_birth':
                self.breast_feeding(child_id, birth_setting='hb')  # hb = home birth
            else:
                self.breast_feeding(child_id, birth_setting='hf')  # hf = health facility

            # ====================================== COMPLICATIONS ====================================================
            # Here we apply risk of complications following birth -first we determine if this child has been born with
            # a congenital anomaly
            self.apply_risk_of_congenital_anomaly(child_id)

            # Next, for all preterm newborns we apply a risk of retinopathy of prematurity
            if df.at[child_id, 'nb_early_preterm'] or df.at[child_id, 'nb_late_preterm']:
                if self.eval(self.nb_linear_models['retinopathy'], child_id):

                    # For newborns with retinopathy we then use a weighted random draw to determine the severity of the
                    # retinopathy to map to DALY weights
                    random_draw = self.rng.choice(('mild', 'moderate', 'severe', 'blindness'),
                                                  p=params['prob_retinopathy_severity'])

                    df.at[child_id, 'nb_retinopathy_prem'] = random_draw
                    logger.debug(key='message', data=f'Neonate {child_id} has developed {random_draw} retinopathy of '
                                                     f'prematurity')

                # and respiratory distress syndrome
                self.apply_risk_of_preterm_respiratory_distress_syndrome(child_id)

            # Finally apply risk of infect, encephalopathy and respiratory depression
            self.apply_risk_of_neonatal_infection_and_sepsis(child_id)
            self.apply_risk_of_encephalopathy(child_id, timing='on_birth')
            self.apply_risk_of_not_breathing_at_birth(child_id)

            # Neonates who were delivered in a facility are automatically scheduled to receive care at birth at the
            # same level of facility that they were delivered in
            if m['delivery_setting'] == 'health_centre':
                event = HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendantAtBirth(
                    self, person_id=child_id, facility_level_of_this_hsi=1)
                self.sim.modules['HealthSystem'].schedule_hsi_event(event, priority=0,
                                                                    topen=self.sim.date,
                                                                    tclose=self.sim.date + DateOffset(days=1))

            if m['delivery_setting'] == 'hospital':
                event = HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendantAtBirth(
                    self, person_id=child_id, facility_level_of_this_hsi=int(self.rng.choice([1, 2])))
                self.sim.modules['HealthSystem'].schedule_hsi_event(event, priority=0,
                                                                    topen=self.sim.date,
                                                                    tclose=self.sim.date + DateOffset(days=1))

            # ========================================== POSTNATAL CHECK  =============================================
            # Finally we determine if this neonate will receive a full postnatal check following their birth and how
            # promptly
            if nci[child_id]['delivery_setting'] != 'home_birth' and ((self.rng.random_sample()
                                                                       < params['prob_pnc_check_newborn']) or
                                                                      (m['pnc_twin_one'] != 'none')):
                self.schedule_pnc(child_id)

            elif nci[child_id]['delivery_setting'] == 'home_birth':

                if df.at[child_id, 'nb_early_onset_neonatal_sepsis'] or \
                    (df.at[child_id, 'nb_encephalopathy'] != 'none') or \
                    df.at[child_id, 'nb_early_preterm'] or \
                   df.at[child_id, 'nb_late_preterm']:
                    care_seeking = params['prob_care_seeking_for_complication']
                else:
                    care_seeking = params['prob_pnc_check_newborn']

                if (self.rng.random_sample() < care_seeking) or (m['pnc_twin_one'] != 'none'):
                    self.schedule_pnc(child_id)

                if nci[child_id]['delivery_setting'] == 'home_birth' and nci[child_id]['will_receive_pnc'] != 'early':
                    self.scheduled_week_one_postnatal_event(child_id)

        if ~df.at[mother_id, 'ps_multiple_pregnancy'] or\
            (df.at[mother_id, 'ps_multiple_pregnancy'] and (m['twin_count'] == 2)) or \
           (df.at[mother_id, 'ps_multiple_pregnancy'] and m['single_twin_still_birth']):

            self.sim.modules['PregnancySupervisor'].further_on_birth_pregnancy_supervisor(mother_id)
            self.sim.modules['PostnatalSupervisor'].further_on_birth_postnatal_supervisor(mother_id, child_id)
            self.sim.modules['CareOfWomenDuringPregnancy'].further_on_birth_care_of_women_in_pregnancy(mother_id)

    def on_hsi_alert(self, person_id, treatment_id):
        logger.info(key='message', data=f'This is NewbornOutcomes, being alerted about a health system interaction '
                                        f'person {person_id} for: {treatment_id}')

    def report_daly_values(self):
        """
        This function reports the DALY weights for this module generated in the previous month
        :return: data frame containing the DALY weights
        """
        logger.debug(key='message', data='This is Newborn Outcomes reporting my health values')

        df = self.sim.population.props
        p = self.parameters['nb_daly_weights']

        # Disability properties are mapped to DALY weights and stored for the health burden module
        health_values_1 = df.loc[df.is_alive, 'nb_retinopathy_prem'].map(
                    {'none': 0, 'mild': p['mild_vision_rptb'], 'moderate': p['moderate_vision_rptb'],
                     'severe': p['severe_vision_rptb'], 'blindness': p['blindness_rptb']})
        health_values_1.name = 'Retinopathy of Prematurity'
        health_values_1 = pd.to_numeric(health_values_1)

        health_values_2 = df.loc[df.is_alive, 'nb_encephalopathy_disab'].map(
            {'none': 0, 'mild_motor': p['mild_motor_enceph'], 'mild_motor_and_cog': p['mild_motor_cognitive_enceph'],
             'moderate_motor': p['moderate_motor_enceph'], 'severe_motor': p['severe_motor_enceph']})
        health_values_2.name = 'Neonatal Encephalopathy'
        health_values_2 = pd.to_numeric(health_values_2)

        health_values_3 = df.loc[df.is_alive, 'nb_neonatal_sepsis_disab'].map(
            {'none': 0, 'mild_motor': p['mild_motor_sepsis'], 'mild_motor_and_cog': p['mild_motor_cognitive_sepsis'],
             'moderate_motor': p['moderate_motor_sepsis'], 'severe_motor': p['severe_motor_sepsis']})
        health_values_3.name = 'Neonatal Sepsis Long term Disability'
        health_values_3 = pd.to_numeric(health_values_3)

        health_values_4 = df.loc[df.is_alive, 'nb_preterm_birth_disab'].map(
            {'none': 0, 'mild_motor': p['mild_motor_preterm'], 'mild_motor_and_cog': p['mild_motor_cognitive_preterm'],
             'moderate_motor': p['moderate_motor_preterm'], 'severe_motor': p['severe_motor_preterm']})
        health_values_4.name = 'Preterm Birth Disability'
        health_values_4 = pd.to_numeric(health_values_4)

        health_values_df = pd.concat([health_values_1.loc[df.is_alive], health_values_2.loc[df.is_alive],
                                     health_values_3.loc[df.is_alive], health_values_4.loc[df.is_alive]], axis=1)

        scaling_factor = (health_values_df.sum(axis=1).clip(lower=0, upper=1) /
                          health_values_df.sum(axis=1)).fillna(1.0)

        health_values_df = health_values_df.multiply(scaling_factor, axis=0)

        return health_values_df


class HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendantAtBirth(HSI_Event, IndividualScopeEventMixin):
    """
    This is HSI_NewbornOutcomes_CareOfTheNewbornBySkilledAttendantAtBirth. It is scheduled by on_birth for any newborns
    who were delivered in a health facility. Currently it applies the effect of interventions that would reasonably be
    delivered as part of the process of birth (i.e. resuscitation of a flat newborn) but is not a full postnatal
    check
    """

    def __init__(self, module, person_id, facility_level_of_this_hsi):
        super().__init__(module, person_id=person_id)
        assert isinstance(module, NewbornOutcomes)

        self.TREATMENT_ID = 'NewbornOutcomes_CareOfTheNewbornBySkilledAttendant'
        self.EXPECTED_APPT_FOOTPRINT = self.make_appt_footprint({'InpatientDays': 1})
        self.ACCEPTED_FACILITY_LEVEL = facility_level_of_this_hsi
        self.ALERT_OTHER_DISEASES = []
        self.BEDDAYS_FOOTPRINT = self.make_beddays_footprint({'general_bed': 1})

    def apply(self, person_id, squeeze_factor):
        nci = self.module.newborn_care_info
        df = self.sim.population.props
        params = self.module.current_parameters

        # Run some checks on the individual
        assert self.sim.date == df.at[person_id, 'date_of_birth']
        assert not df.at[person_id, 'nb_death_after_birth']
        assert nci[person_id]['delivery_setting'] != 'home_birth'

        if not df.at[person_id, 'is_alive']:
            return

        # Currently the primary intervention delivered by this HSI is newborn resuscitation, we assume that this is
        # part of the care around labour and is distinct from the postnatal check (as the newborn requiring resus is
        # evident at birth)
        if nci[person_id]['delivery_setting'] == 'health_centre':
            facility_type_code = 'hc'
        else:
            facility_type_code = 'hp'

        if squeeze_factor < params['squeeze_threshold_neonatal_resus']:
            self.module.assessment_and_initiation_of_neonatal_resus(self, facility_type_code)

        if not nci[person_id]['will_receive_pnc'] == 'early':
            self.module.set_death_status(person_id)

    def did_not_run(self):
        person_id = self.target

        logger.debug(key='message', data=f'Neonate {person_id} did not receive care at birth as the squeeze factor '
                                         f'was too high')
        return False

    def not_available(self):
        person_id = self.target
        logger.debug(key='message', data=f'Neonate {person_id} did not receive care at birth as this HSI is not '
                                         f'allowed in current configuration')
        return False


class HSI_NewbornOutcomes_ReceivesPostnatalCheck(HSI_Event, IndividualScopeEventMixin):
    """
    This is HSI_NewbornOutcomes_ReceivesEarlyPostnatalCheck. This event is scheduled on_birth for all neonates who are
    predicted to receive a full postnatal checkup within the first 2 days of life following either home birth or
    facility delivery. Interventions within in this event include management of essential newborn care, initiation of
    kangaroo mother care, newborn immunisation, HIV screening and management of early onset neonatal sepsis,
    """

    def __init__(self, module, person_id, facility_level_of_this_hsi):
        super().__init__(module, person_id=person_id)
        assert isinstance(module, NewbornOutcomes)

        self.TREATMENT_ID = 'NewbornOutcomes_ReceivesEarlyPostnatalCheck'
        self.EXPECTED_APPT_FOOTPRINT = self.make_appt_footprint({'InpatientDays': 1})
        self.ACCEPTED_FACILITY_LEVEL = facility_level_of_this_hsi
        self.ALERT_OTHER_DISEASES = []
        self.BEDDAYS_FOOTPRINT = self.make_beddays_footprint({'general_bed': 2})

    def apply(self, person_id, squeeze_factor):
        nci = self.module.newborn_care_info
        df = self.sim.population.props
        params = self.module.current_parameters

        if not df.at[person_id, 'is_alive'] or df.at[person_id, 'nb_death_after_birth'] or (person_id not in nci):
            return

        if (nci[person_id]['will_receive_pnc'] == 'early') and not nci[person_id]['passed_through_week_one']:
            assert self.sim.date <= (df.at[person_id, 'date_of_birth'] + pd.DateOffset(days=1))
            assert df.at[person_id, 'nb_pnc_check'] == 0

        elif nci[person_id]['will_receive_pnc'] == 'late' and not nci[person_id]['passed_through_week_one']:
            assert self.sim.date >= (df.at[person_id, 'date_of_birth'] + pd.DateOffset(days=2))
            assert df.at[person_id, 'nb_pnc_check'] == 0

        # Log the PNC check
        logger.info(key='postnatal_check', data={'person_id': person_id,
                                                 'delivery_setting': nci[person_id]['delivery_setting'],
                                                 'visit_number': df.at[person_id, 'nb_pnc_check'],
                                                 'timing': nci[person_id]['will_receive_pnc']})

        df.at[person_id, 'nb_pnc_check'] += 1

        # This HSI contains the interventions delivered as part of a full postnatal check of the newborn after birth -
        # this include newborns who delivered at home or in facility
        if nci[person_id]['delivery_setting'] == 'health_centre':
            facility_type_code = 'hc'
        elif nci[person_id]['delivery_setting'] == 'hospital':
            facility_type_code = 'hp'
        elif nci[person_id]['delivery_setting'] == 'home_birth':
            if self.ACCEPTED_FACILITY_LEVEL == 2:
                facility_type_code = 'hp'
            else:
                facility_type_code = self.module.rng.choice(['hc', 'hp'])

        # First the newborn is assessed for sepsis and treated if needed
        if squeeze_factor < params['squeeze_threshold_sepsis_treatment']:
            self.module.assessment_and_treatment_newborn_sepsis(self, facility_type_code)

        # Next, interventions pertaining to essential newborn care
        if df.at[person_id, 'nb_pnc_check'] == 1:
            if squeeze_factor < params['squeeze_threshold_essential_newborn_care']:
                self.module.essential_newborn_care(self)

            # ...and invitation of kangaroo mother care for small infants
            if squeeze_factor < params['squeeze_threshold_kmc']:
                self.module.kangaroo_mother_care(self, facility_type_code)

            # Finally these newborns will receive immunisation and HIV screening if at risk
                self.module.immunisations(person_id)
                self.module.hiv_screening_for_at_risk_newborns(person_id)

        self.module.set_death_status(person_id)

        # Surviving neonates with complications on day 1 are admitted to the inpatient event which lives in the
        # Postnatal Supervisor module
        if df.at[person_id, 'nb_early_onset_neonatal_sepsis'] or (df.at[person_id, 'nb_encephalopathy'] != 'none')\
            or df.at[person_id, 'nb_early_preterm'] or df.at[person_id, 'nb_late_preterm'] or\
            df.at[person_id, 'nb_kangaroo_mother_care']:

            event = HSI_NewbornOutcomes_NeonatalWardInpatientCare(
                    self.module, person_id=person_id)
            self.sim.modules['HealthSystem'].schedule_hsi_event(event, priority=0, topen=self.sim.date, tclose=None)

    def did_not_run(self):
        person_id = self.target

        logger.debug(key='message', data=f'Neonate {person_id} did not receive care after birth as the squeeze factor '
                                         f'was too high')
        return False

    def not_available(self):
        person_id = self.target
        logger.debug(key='message', data=f'Neonate {person_id} did not receive care after birth as this HSI is not '
                                         f'allowed in current configuration')
        return False


class HSI_NewbornOutcomes_NeonatalWardInpatientCare(HSI_Event, IndividualScopeEventMixin):
    """This is HSI_PostnatalSupervisor_NeonatalWardInpatientCare. It is scheduled by any of the PNC HSIs for neonates
    who are require inpatient care due to a complication of the postnatal period. Treatment is delivered in this
    event"""

    def __init__(self, module, person_id):
        super().__init__(module, person_id=person_id)
        assert isinstance(module, NewbornOutcomes)

        self.TREATMENT_ID = 'NewbornOutcomes_NeonatalWardInpatientCare'
        self.EXPECTED_APPT_FOOTPRINT = self.make_appt_footprint({'IPAdmission': 1})
        self.ACCEPTED_FACILITY_LEVEL = 1
        self.ALERT_OTHER_DISEASES = []
        self.BEDDAYS_FOOTPRINT = self.make_beddays_footprint({'general_bed': 5}) # todo

    def apply(self, person_id, squeeze_factor):

        logger.debug(key='message', data='HSI_PostnatalSupervisor_NeonatalWardInpatientCare now running to capture '
                                         'inpatient time for an unwell newborn')

    def did_not_run(self):
        logger.debug(key='message', data='HSI_PostnatalSupervisor_NeonatalWardInpatientCare: did not run')
        return False

    def not_available(self):
        logger.debug(key='message', data='HSI_PostnatalSupervisor_NeonatalWardInpatientCare: cannot not run with '
                                         'this configuration')
        return False


class BreastfeedingStatusUpdateEventSixMonths(Event, IndividualScopeEventMixin):
    """ This is BreastfeedingStatusUpdateEventSixMonths. It is scheduled via the breastfeeding function.
    Children who are alive and still breastfeeding by six months have their breastfeeding status updated. Those who will
    continue to breastfeed are scheduled BreastfeedingStatusUpdateEventTwoYears
    """

    def __init__(self, module, individual_id):
        super().__init__(module, person_id=individual_id)

    def apply(self, individual_id):
        df = self.sim.population.props
        child = df.loc[individual_id]

        if not child.is_alive:
            return

        # For infants who are exclusively breastfeeding at 6 months, we determine if they will change to non-exclusive
        # feeding or no breastfeeding
        if child.nb_breastfeeding_status == 'exclusive':
            random_draw = self.module.rng.choice(('non_exclusive', 'none'), p=[0.5, 0.5])
            df.at[individual_id, 'nb_breastfeeding_status'] = random_draw

        # Similarly, for infants who are non-exclusively breastfeeding at 6 months we determine if they will continue
        # non-exclusively breastfeeding or stop breastfeeding all together
        if child.nb_breastfeeding_status == 'non_exclusive':
            random_draw = self.module.rng.choice(('non_exclusive', 'none'), p=[0.5, 0.5])
            df.at[individual_id, 'nb_breastfeeding_status'] = random_draw

        # We then schedule these breastfed newborns to return at 2 years to update breastfeeding status again
        if child.nb_breastfeeding_status != 'none':
            self.sim.schedule_event(BreastfeedingStatusUpdateEventTwoYears(self.module, individual_id),
                                    self.sim.date + DateOffset(months=18))


class BreastfeedingStatusUpdateEventTwoYears(Event, IndividualScopeEventMixin):
    """ This is BreastfeedingStatusUpdateEventTwoYears. It is scheduled via the breastfeeding function.
    Children who are alive and still breastfeeding by two years months have their breastfeeding status updated."""

    def __init__(self, module, individual_id):
        super().__init__(module, person_id=individual_id)

    def apply(self, individual_id):
        df = self.sim.population.props

        if not df.at[individual_id, 'is_alive']:
            return

        df.at[individual_id, 'nb_breastfeeding_status'] = 'none'


class NewbornOutcomesLoggingEvent(RegularEvent, PopulationScopeEventMixin):
    """ This is NewbornOutcomesLoggingEvent. The event runs every year and calculates yearly
    incidence of key outcomes following birth, and logs them in a dataframe to be used by analysis
    files """
    def __init__(self, module):
        self.repeat = 1
        super().__init__(module, frequency=DateOffset(years=self.repeat))

    def apply(self, population):
        df = self.sim.population.props

        pass

