"""
This file will read in the output files generated by model runs
then employs a series of helper functions to
generate life tables to estimate life expectancy for each run/draw

function: produce_life_expectancy_estimates() will produce summary statistics
or will output life expectancy at birth for M and F separately for every
run/draw if argument(...median=False)

"""

from pathlib import Path

import pandas as pd

from tlo import Date

from tlo.analysis.utils import (
    extract_results,
    get_scenario_info,
    load_pickled_dataframes,
)

# define the target period over which we want to estimate life expectancy
# this should be a one-year period
TARGET_PERIOD = (Date(2019, 1, 1), Date(2020, 1, 1))


# %% --------------------------------------------------------------
# HELPER FUNCTIONS


def _map_age_to_age_group(dataframe):
    """
    Maps ages to age-groups in 5-year intervals and adds a new column 'age-group' to the DataFrame.

    Args:
    - dataframe (pd.DataFrame): The DataFrame containing the age data.
    - age_column (str): The name of the column containing ages.

    Returns:
    - pd.DataFrame: The DataFrame with the 'age-group' column added.
    """
    # Define age groups in 5-year intervals
    age_groups = ['0'] + ['1-4'] + [f'{start}-{start + 4}' for start in range(5, 90, 5)] + ['90+']

    # Create a new column 'age-group' based on the age-to-age-group mapping
    dataframe['age_group'] = pd.cut(dataframe['age'], bins=[0] + [1] + list(range(5, 95, 5)) + [float('inf')],
                                    labels=age_groups, right=False)

    return dataframe


def _create_multi_index_columns(results_folder: Path):
    info = get_scenario_info(results_folder)

    return pd.MultiIndex.from_product([range(info['number_of_draws']),
                                       range(info['runs_per_draw'])],
                                      names=['draw', 'run'])


# %% extract key population data for life expectancy calculations
def _num_deaths_by_age_group(results_folder: Path):
    """ produces dataframe with mean (+ 95% UI) number of deaths
    for each draw by age-group
    dataframe returned: rows=age-gp, columns=draw median, draw lower, draw upper
    """

    def extract_deaths_by_age_group(df: pd.DataFrame) -> pd.Series:
        # Call the function to add the 'age-group' column
        df = _map_age_to_age_group(df)
        return df.loc[pd.to_datetime(df.date).between(*TARGET_PERIOD)].groupby(["age_group", "sex"])[
            "person_id"].count()

    return extract_results(
        results_folder,
        module="tlo.methods.demography",
        key="death",
        custom_generate_series=extract_deaths_by_age_group,
        do_scaling=False
    )


# get population size in target period
# get one row of log for each draw/run and compile into df
def _extract_pop_during_target_period(results_folder: Path, key):
    info = get_scenario_info(results_folder)

    module = "tlo.methods.demography"
    key = key

    # Create an empty DataFrame with the specified multi-index columns
    multi_index_columns = _create_multi_index_columns(results_folder)
    res = pd.DataFrame(columns=multi_index_columns)

    for draw in range(info['number_of_draws']):
        for run in range(info['runs_per_draw']):
            df: pd.DataFrame = load_pickled_dataframes(results_folder, draw, run, module)[module][key]
            output_from_eval: pd.Series = df.loc[pd.to_datetime(df.date).between(*TARGET_PERIOD)].stack()
            res.loc[:, (draw, run)] = output_from_eval[1:]

    return res


def _get_population_size_by_age(results_folder):
    def extract_infants_during_target_period(df: pd.DataFrame) -> pd.Series:
        return df.loc[pd.to_datetime(df.date).between(*TARGET_PERIOD), '0']

    # get children aged=0 in target period
    num_children = extract_results(
        results_folder,
        module="tlo.methods.demography",
        key="num_children",
        custom_generate_series=extract_infants_during_target_period,
        do_scaling=False
    )
    num_f0 = num_children / 2  # todo should this be exactly 50/50?
    num_m0 = num_children / 2

    # get age_range_m and age_range_f for all age-groups
    num_males = _extract_pop_during_target_period(results_folder=results_folder, key='age_range_m')
    num_females = _extract_pop_during_target_period(results_folder=results_folder, key='age_range_f')
    num_males = num_males.reset_index(level=0, drop=True)
    num_females = num_females.reset_index(level=0, drop=True)

    # then subtract age 0 from age-group 0-4
    num_males_adj = num_males.iloc[0:1, :] - num_m0.iloc[0:1, :].values
    # add adjusted data back into dataframe
    num_males.iloc[0] = num_males_adj.values
    # change first row index
    num_males.index.values[0] = '1-4'
    # add in infant numbers to main dataframe
    t1 = pd.concat([num_m0, num_males])
    # set correct index
    t1.index.values[0] = '0'

    # repeat for females
    num_females_adj = num_females.iloc[0:1, :] - num_f0.iloc[0:1, :].values
    num_females.iloc[0] = num_females_adj.values
    num_females.index.values[0] = '1-4'
    t2 = pd.concat([num_f0, num_females])
    t2.index.values[0] = '0'

    # combine pop aged 90+
    # Sum the last three rows column-wise
    last_three_rows_sum = t1.iloc[-3:].sum()
    t1.loc['90+'] = last_three_rows_sum

    last_three_rows_sum = t2.iloc[-3:].sum()
    t2.loc['90+'] = last_three_rows_sum

    # remove unneeded columns
    indices_to_remove = ['90-94', '95-99', '100+']
    t1 = t1.drop(indices_to_remove, axis=0)
    t2 = t2.drop(indices_to_remove, axis=0)

    # output is 0, 1-4, 5-9, 10-14 and index by male/female
    # join male and female dataframe and add index for sex
    t3 = pd.concat([t1, t2], ignore_index=True)

    # Create a MultiIndex for rows using age group and 'Male' and 'Female'
    multi_index_rows_male = pd.MultiIndex.from_product([t1.index, ['M']], names=['age_group', 'sex'])
    multi_index_rows_female = pd.MultiIndex.from_product([t1.index, ['F']], names=['age_group', 'sex'])
    t3.index = multi_index_rows_male.append(multi_index_rows_female)

    return t3


# %% GENERATE LIFE EXPECTANCY ESTIMATES

def _estimate_life_expectancy(person_years_at_risk, number_of_deaths_in_interval):
    """
    for a single run, estimate life expectancy for males and females
    return: pd.Series
    """

    estimated_life_expectancy = pd.Series(dtype=float)

    # first age-group is 0, then 1-4, 5-9, 10-14 etc. 22 categories in total
    level_0_values = person_years_at_risk.index.get_level_values('age_group').unique()
    interval_width = pd.Series([1] + [4] + [5] * 18, index=level_0_values)

    fraction_of_last_age_survived = 0.5
    number_age_groups = 20

    # separate male and female data
    for sex in ['M', 'F']:
        person_years_by_sex = person_years_at_risk.xs(key=sex, level='sex')
        number_of_deaths_by_sex = number_of_deaths_in_interval.xs(key=sex, level='sex')

        death_rate_in_interval = number_of_deaths_by_sex / person_years_by_sex
        # if no deaths or person-years, convert nan to 0
        death_rate_in_interval = death_rate_in_interval.fillna(0)
        # if no deaths in age 90+, set death rate equal to value in age 85-89
        if death_rate_in_interval[number_age_groups - 1] == 0:
            death_rate_in_interval[number_age_groups - 1] = death_rate_in_interval[number_age_groups - 2]

        # Calculate the probability of dying in the interval
        condition = number_of_deaths_by_sex > (
            person_years_by_sex / interval_width / fraction_of_last_age_survived)
        probability_of_dying_in_interval = pd.Series(index=number_of_deaths_by_sex.index, dtype=float)
        probability_of_dying_in_interval[condition] = 1
        probability_of_dying_in_interval[~condition] = interval_width * death_rate_in_interval / (
            1 + interval_width * (1 - fraction_of_last_age_survived) * death_rate_in_interval)
        # all those surviving to final interval die during this interval
        probability_of_dying_in_interval[number_age_groups - 1] = 1

        # number_alive_at_start_of_interval
        # keep dtype as float in case using aggregated outputs
        # note range stops BEFORE the specified number
        number_alive_at_start_of_interval = pd.Series(index=range(number_age_groups), dtype=float)
        number_alive_at_start_of_interval[0] = 100_000  # hypothetical cohort
        for i in range(1, number_age_groups):
            number_alive_at_start_of_interval[i] = (1 - probability_of_dying_in_interval[i - 1]) * \
                                                   number_alive_at_start_of_interval[i - 1]

        # number_dying_in_interval
        number_dying_in_interval = pd.Series(index=range(number_age_groups), dtype=float)
        for i in range(0, number_age_groups - 1):
            number_dying_in_interval[i] = number_alive_at_start_of_interval[i] - number_alive_at_start_of_interval[
                i + 1]

        number_dying_in_interval[number_age_groups - 1] = number_alive_at_start_of_interval[number_age_groups - 1]

        # person-years lived in interval
        py_lived_in_interval = pd.Series(index=range(number_age_groups), dtype=float)
        for i in range(0, number_age_groups - 1):
            py_lived_in_interval[i] = interval_width[i] * (
                number_alive_at_start_of_interval[i + 1] + fraction_of_last_age_survived * number_dying_in_interval[i])
        py_lived_in_interval[number_age_groups - 1] = number_alive_at_start_of_interval[number_age_groups - 1] / \
                                                      death_rate_in_interval[number_age_groups - 1]

        # person-years lived beyond start of interval
        # have to iterate backwards for this
        py_lived_beyond_start_of_interval = pd.Series(index=range(number_age_groups), dtype=float)
        py_lived_beyond_start_of_interval[number_age_groups - 1] = py_lived_in_interval[number_age_groups - 1]
        for i in range((number_age_groups - 2), -1, -1):
            py_lived_beyond_start_of_interval[i] = py_lived_beyond_start_of_interval[i + 1] + py_lived_in_interval[i]

        # calculate observed life expectancy at start of interval
        condition = number_alive_at_start_of_interval == 0
        observed_life_expectancy = pd.Series(index=range(number_age_groups), dtype=float)
        observed_life_expectancy[condition] = 0
        observed_life_expectancy[~condition] = py_lived_beyond_start_of_interval / number_alive_at_start_of_interval

        # estimated life expectancy from birth
        estimated_life_expectancy = estimated_life_expectancy.append(pd.Series([observed_life_expectancy[0]]))

    return estimated_life_expectancy


# generate life expectancy estimates for all draws/runs
def produce_life_expectancy_estimates(results_folder: Path, median=True):
    """
    produces sets of life expectancy estimates for each draw/run
    calls:
    *1 num_deaths_by_age_group
    *2 aggregate_person_years_by_age

    Args:
    - results_folder (PosixPath): The path to the folder containing all logged outputs
    - median: declare whether to return a median value with 95% uncertainty intervals
    or return the estimate for each draw/run

    Returns:
    - pd.DataFrame: The DataFrame with the life expectancy estimates (in years)
    for every draw/run in the results folder
    """
    info = get_scenario_info(results_folder)

    output = pd.DataFrame()

    # extract numbers of deaths
    deaths = _num_deaths_by_age_group(results_folder)

    # extract person-years
    person_years = _get_population_size_by_age(results_folder)

    for draw in range(info['number_of_draws']):
        for run in range(info['runs_per_draw']):
            # select column
            le = _estimate_life_expectancy(
                number_of_deaths_in_interval=deaths.loc[:, (draw, run)],
                person_years_at_risk=person_years.loc[:, (draw, run)])

            output = pd.concat([output, le], axis=1)

    multi_index_columns = _create_multi_index_columns(results_folder)
    output.columns = multi_index_columns
    output.index = ['M', 'F']

    if not median:
        return output

    else:
        summary = pd.DataFrame(
            columns=pd.MultiIndex.from_product(
                [
                    output.columns.unique(level='draw'),
                    ["median", "lower", "upper"]
                ],
                names=['draw', 'stat']),
            index=output.index
        )

        summary.loc[:, (slice(None), "median")] = output.groupby(axis=1, by='draw').median().values
        summary.loc[:, (slice(None), "lower")] = output.groupby(axis=1, by='draw').quantile(0.025).values
        summary.loc[:, (slice(None), "upper")] = output.groupby(axis=1, by='draw').quantile(0.975).values

        return summary
