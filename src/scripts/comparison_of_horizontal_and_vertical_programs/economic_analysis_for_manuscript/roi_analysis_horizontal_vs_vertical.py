"""
This script generates results for the Horizontal versus Vertical investments paper.
The latest job_ID used for the analysis is -
Completed in Jan 2025:
htm_and_hss_runs-2025-01-16T135243Z
This is generated by ~/src/scripts/comparison_of_horizontal_and_vertical_programs/manuscript_analyses/scenario_hss_htm_paper.py
"""
import datetime
import os
import string
import textwrap
from collections import defaultdict
from pathlib import Path
from typing import Optional

import matplotlib.colors as mcolors
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt
from scipy.spatial import ConvexHull # for frontier plot
import numpy as np
import pandas as pd
import seaborn as sns
from adjustText import adjust_text  # For the CEA plane figure to avoid overlaps in data labels

from scripts.costing.cost_estimation import (
    apply_discounting_to_cost_data,
    do_line_plot_of_cost,
    do_stacked_bar_plot_of_cost_by_category,
    estimate_input_cost_of_scenarios,
    estimate_projected_health_spending,
    extract_roi_at_specific_implementation_costs,
    generate_multiple_scenarios_roi_plot,
    load_unit_cost_assumptions,
    summarize_cost_data,
    tabulate_roi_estimates,
)
from tlo import Date
from tlo.analysis.utils import (
    extract_params,
    extract_results,
    get_scenario_info,
    get_scenario_outputs,
    load_pickled_dataframes,
)

# Define a timestamp for script outputs
timestamp = datetime.datetime.now().strftime("_%Y_%m_%d_%H_%M")

# Print the start time of the script
print('Script Start', datetime.datetime.now().strftime('%H:%M'))

# Create folders to store results
resourcefilepath = Path("./resources")
outputfilepath = Path('./outputs/t.mangal@imperial.ac.uk')
main_figurespath = Path('./outputs/horizontal_v_vertical_firstrevision')
if not os.path.exists(main_figurespath):
    os.makedirs(main_figurespath)

# Load result files
# ------------------------------------------------------------------------------------------------------------------
results_folder = get_scenario_outputs('htm_and_hss_runs-2025-09-16T141811Z.py', outputfilepath)[0]

# Check can read results from draw=0, run=0
log = load_pickled_dataframes(results_folder, 0, 0)  # look at one log (so can decide what to extract)
params = extract_params(results_folder)
info = get_scenario_info(results_folder)

# Declare default parameters for cost analysis
# ------------------------------------------------------------------------------------------------------------------
# Population scaling factor for malaria scale-up projections
population_scaling_factor = log['tlo.methods.demography']['scaling_factor']['scaling_factor'].iloc[0]
# Load the list of districts and their IDs
district_dict = pd.read_csv(resourcefilepath / 'demography' / 'ResourceFile_Population_2010.csv')[
    ['District_Num', 'District']].drop_duplicates()
district_dict = dict(zip(district_dict['District_Num'], district_dict['District']))

# Period relevant for costing
TARGET_PERIOD = (Date(2025, 1, 1), Date(2035, 12, 31))  # This is the period that is costed
relevant_period_for_costing = [i.year for i in TARGET_PERIOD]
list_of_relevant_years_for_costing = list(range(relevant_period_for_costing[0], relevant_period_for_costing[1] + 1))

# Choose central metric used - mean or median
chosen_metric = 'median'

# Scenarios
# Full list of scenarios used in the manuscript
main_manuscript_scenarios = {0: "Baseline",
                            1: "Pessimistic HRH Scale-up", 2: "Historical HRH Scale-up",
                            3: "Optimistic HRH Scale-up",
                            4: "Consumables Increased to 75th Percentile",
                            5: "Consumables Increased to HIV levels", 6: "Consumables Increased to EPI Levels",
                            7: "HSS Expansion Package",
                            8: "HIV Program Scale-up Without HSS Expansion",
                            15: "HIV Program Scale-up With HSS Expansion Package",
                            16: "TB Program Scale-up Without HSS Expansion",
                            23: "TB Program Scale-up With HSS Expansion Package",
                            24: "Malaria Program Scale-up Without HSS Expansion",
                            31: "Malaria Program Scale-up With HSS Expansion Package",
                            32: "HTM Programs Scale-up Without HSS Expansion",
                            39: "HTM Programs Scale-up With HSS Expansion Package"}

frontier_scenarios = {9:"HIV Program Scale-up With Pessimistic HRH Scale-up",
                      10:"HIV Program Scale-up With Historical HRH Scale-up",
                      11:"HIV Program Scale-up With Optimistic HRH Scale-up",
                      12:"HIV Program Scale-up With Consumables Increased to 75th Percentile",
                      13:"HIV Program Scale-up With Consumables Increased to HIV levels",
                      14:"HIV Program Scale-up With Consumables Increased to EPI Levels",
                      17:"TB Program Scale-up With Pessimistic HRH Scale-up",
                      18:"TB Program Scale-up With Historical HRH Scale-up",
                      19:"TB Program Scale-up With Optimistic HRH Scale-up",
                      20:"TB Program Scale-up With Consumables Increased to 75th Percentile",
                      21:"TB Program Scale-up With Consumables Increased to HIV levels",
                      22:"TB Program Scale-up With Consumables Increased to EPI Levels",
                      25:"Malaria Program Scale-up With Pessimistic HRH Scale-up",
                      26:"Malaria Program Scale-up With Historical HRH Scale-up",
                      27:"Malaria Program Scale-up With Optimistic HRH Scale-up",
                      28:"Malaria Program Scale-up With Consumables Increased to 75th Percentile",
                      29:"Malaria Program Scale-up With Consumables Increased to HIV levels",
                      30:"Malaria Program Scale-up With Consumables Increased to EPI Levels",
                      33:"HTM Scale-up With Pessimistic HRH Scale-up",
                      34:"HTM Scale-up With Historical HRH Scale-up",
                      35:"HTM Scale-up With Optimistic HRH Scale-up",
                      36:"HTM Scale-up With Consumables Increased to 75th Percentile",
                      37:"HTM Scale-up With Consumables Increased to HIV levels",
                      38:"HTM Scale-up With Consumables Increased to EPI Levels",
                      40:"HIV + TB Scale-up Without HSS Expansion",
                      41:"HIV + TB Scale-up With Historical HRH Scale-up",
                      42:"HIV + TB Scale-up With Consumables Increased to 75th Percentile",
                      43:"HIV + TB Scale-up With HSS Expansion",
                      44:"HIV + Malaria Scale-up Without HSS Expansion",
                      45:"HIV + Malaria Scale-up With Historical HRH Scale-up",
                      46:"HIV + Malaria Scale-up With Consumables Increased to 75th Percentile",
                      47:"HIV + Malaria Scale-up With HSS Expansion",
                      48:"TB + Malaria Scale-up Without HSS Expansion",
                      49:"TB + Malaria Scale-up With Historical HRH Scale-up",
                      50:"TB + Malaria Scale-up With Consumables Increased to 75th Percentile",
                      51:"TB + Malaria Scale-up With HSS Expansion"}

all_manuscript_scenarios = {**main_manuscript_scenarios, **frontier_scenarios}

all_manuscript_scenarios_reverse = {v: k for k, v in all_manuscript_scenarios.items()}

baseline = all_manuscript_scenarios_reverse.get("Baseline")
horizontal_hss = all_manuscript_scenarios_reverse.get("HSS Expansion Package")
vertical_hiv = all_manuscript_scenarios_reverse.get("HIV Program Scale-up Without HSS Expansion")
vertical_tb = all_manuscript_scenarios_reverse.get("TB Program Scale-up Without HSS Expansion")
vertical_malaria = all_manuscript_scenarios_reverse.get("Malaria Program Scale-up Without HSS Expansion")
vertical_htm = all_manuscript_scenarios_reverse.get("HTM Programs Scale-up Without HSS Expansion")
diagonal_hiv = all_manuscript_scenarios_reverse.get("HIV Program Scale-up With HSS Expansion Package")
diagonal_tb = all_manuscript_scenarios_reverse.get("TB Program Scale-up With HSS Expansion Package")
diagonal_malaria = all_manuscript_scenarios_reverse.get("Malaria Program Scale-up With HSS Expansion Package")
diagonal_htm = all_manuscript_scenarios_reverse.get("HTM Programs Scale-up With HSS Expansion Package")

# Use letters instead of full scenario name for figures
all_manuscript_scenarios_substitutedict = {0: "0", 1: "A", 2: "B", 3: "C", 4: "D", 5: "E", 6: "F", 7: "G", 8: "H",
                                           15: "I", 16: "J", 23: "K", 24: "L", 31: "M", 32: "N", 39: "O"}


# Function to adjust color brightness (lighten/darken)
def adjust_color(hex_color, factor=0.5):
    rgb = mcolors.hex2color(hex_color)  # Convert hex to RGB
    adjusted_rgb = [(1 - factor) * c + factor * 1 for c in rgb]  # Lighten
    return mcolors.to_hex(adjusted_rgb)


# Generate color map
color_map = {
    # Baseline (single color)
    'Baseline': 'black',
    # HR scenarios
    "Pessimistic HRH Scale-up": adjust_color('#9e0142', 0.5),
    "Historical HRH Scale-up": adjust_color('#9e0142', 0.5),
    "Optimistic HRH Scale-up": adjust_color('#9e0142', 0.5),
    # Consumables scenarios
    "Consumables Increased to 75th Percentile": adjust_color('#9e0142', 0.5),
    "Consumables Increased to HIV levels": adjust_color('#9e0142', 0.5),
    "Consumables Increased to EPI Levels": adjust_color('#9e0142', 0.5),
    # HIV scenarios
    "HIV Program Scale-up Without HSS Expansion": adjust_color('#fdae61', 0.5),
    "HIV Program Scale-up With HSS Expansion Package": adjust_color('#66c2a5', 0.5),
    # TB scenarios
    "TB Program Scale-up Without HSS Expansion": adjust_color('#fdae61', 0.5),
    "TB Program Scale-up With HSS Expansion Package": adjust_color('#66c2a5', 0.5),
    # Malaria scenarios
    "Malaria Program Scale-up Without HSS Expansion": adjust_color('#fdae61', 0.5),
    "Malaria Program Scale-up With HSS Expansion Package": adjust_color('#66c2a5', 0.5),
    # HSS scenarios
    "HSS Expansion Package": adjust_color('#9e0142', 0.1),  # Darker
    # HTM scenarios
    "HTM Programs Scale-up Without HSS Expansion": adjust_color('#fdae61', 0.1),
    "HTM Programs Scale-up With HSS Expansion Package": adjust_color('#66c2a5', 0.1),
}

# Cost-effectiveness threshold
chosen_cet = 191.4304166  # This is based on the estimate from Lomas et al (2023)- $160.595987085533 in 2019 USD coverted to 2023 USD
# based on Ochalek et al (2018) - the paper provided the value $61 in 2016 USD terms, this value is $77.4 in 2023 USD terms
chosen_value_of_statistical_life = 834  # This is based on Munthali et al (2020) National Planning Commission Report on
# "Medium and long-term impacts of a moderate lockdown (social restrictions) in response to the COVID-19 pandemic in Malawi"
chosen_value_of_statistical_life_upper = 2427.31  # upper bound estimated using Robinson et al method (income elasticity of VSL = 1)
chosen_value_of_statistical_life_lower = 425.96  # lower bound estimated using Robinson et al method (income elasticity of VSL = 1.5)
# lomas_consumption_value_of_health = 257.472 # this value is for 2025 (converted to 2023 USD)
# and assumed income elasticity of consumption value of health to be 1.

# Above service level costs as a percentage of service level costs (This is used for the interpretation of ROI results)
# As per Opuni et al (2023), service level costs were 42% of the total cost --> above service level costs were 58% of total or 138% of sevice level costs
above_service_level_cost_proportion = 1.38


# Define a function to create bar plots
def do_standard_bar_plot_with_ci(_df, set_colors=None, annotations=None,
                                 xticklabels_horizontal_and_wrapped=False,
                                 put_labels_in_legend=True,
                                 offset=1e6):
    """Make a vertical bar plot for each row of _df, using the columns to identify the height of the bar and the
     extent of the error bar."""

    substitute_labels = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

    yerr = np.array([
        (_df[chosen_metric] - _df['lower']).values,
        (_df['upper'] - _df[chosen_metric]).values,
    ])

    xticks = {(i + 0.5): k for i, k in enumerate(_df.index)}

    if set_colors:
        colors = [color_map.get(series, 'grey') for series in _df.index]
    else:
        cmap = sns.color_palette('Spectral', as_cmap=True)
        rescale = lambda y: (y - np.min(y)) / (np.max(y) - np.min(y))  # noqa: E731
        colors = list(map(cmap, rescale(np.array(list(xticks.keys()))))) if put_labels_in_legend else None

    fig, ax = plt.subplots(figsize=(10, 5))
    ax.bar(
        xticks.keys(),
        _df[chosen_metric].values,
        yerr=yerr,
        ecolor='black',
        color=colors,
        capsize=10,
        label=xticks.values()
    )

    if annotations:
        for xpos, (ypos, text) in zip(xticks.keys(), zip(_df['upper'].values.flatten(), annotations)):
            annotation_y = ypos + offset

            ax.text(
                xpos,
                annotation_y,
                '\n'.join(text.split(' ', 1)),
                horizontalalignment='center',
                verticalalignment='bottom',  # Aligns text at the bottom of the annotation position
                fontsize='x-small',
                rotation='horizontal'
            )

    ax.set_xticks(list(xticks.keys()))

    if put_labels_in_legend:
        # Update xticks label with substitute labels
        # Insert legend with updated labels that shows correspondence between substitute label and original label
        # Use all_manuscript_scenarios for the legend
        xtick_legend = [f'{letter}: {all_manuscript_scenarios.get(label, label)}' for letter, label in
                        zip(substitute_labels, xticks.values())]
        xtick_values = [letter for letter, label in zip(substitute_labels, xticks.values())]

        h, legs = ax.get_legend_handles_labels()
        ax.legend(h, xtick_legend, loc='center left', fontsize='small', bbox_to_anchor=(1, 0.5))
        ax.set_xticklabels(xtick_values)
    else:
        if not xticklabels_horizontal_and_wrapped:
            # xticklabels will be vertical and not wrapped
            ax.set_xticklabels(list(xticks.values()), rotation=90)
        else:
            wrapped_labs = ["\n".join(textwrap.wrap(_lab, 20)) for _lab in xticks.values()]
            ax.set_xticklabels(wrapped_labs)

    # Extend ylim to accommodate data labels
    ymin, ymax = ax.get_ylim()
    extension = 0.1 * (ymax - ymin)  # 10% of range
    ax.set_ylim(ymin - extension, ymax + extension)  # Set new y-axis limits with the extended range

    ax.grid(axis="y")
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    # fig.tight_layout()
    fig.tight_layout(pad=2.0)
    plt.subplots_adjust(left=0.15, right=0.85)  # Adjust left and right margins

    return fig, ax

# Thi sis a helper function for the upper_convex_frontier_from_dict
def prune_inward_tail(frontier_cd, frontier_draws, tol=1e-9):
    """Remove any final points that violate the upper-hull orientation or reduce DALYs."""
    keep = []
    for i, (c, v) in enumerate(frontier_cd):
        while len(keep) >= 2:
            o = frontier_cd[keep[-2]]
            a = frontier_cd[keep[-1]]
            # same orientation test we used to build the hull
            z = (a[0] - o[0]) * (v - a[1]) - (a[1] - o[1]) * (c - a[0])
            if z > tol:  # concave upward -> drop 'a'
                keep.pop()
            else:
                break
        # also enforce non-decreasing DALYs with increasing cost
        if not keep or v >= frontier_cd[keep[-1], 1] - tol:
            keep.append(i)
    return frontier_cd[keep], [frontier_draws[i] for i in keep]

# The function below helps construct a frontier on a cost-effectiveness plane
def upper_convex_frontier_from_dict(points_by_draw, include_collinear=False, tol=1e-12):
    """
    points_by_draw: dict[draw_id] -> (cost, dalys), both incremental vs the *same baseline*.
    Returns:
      draws_on_frontier (ascending cost), frontier_cd (Nx2 array of (cost, dalys)).
    Removes strictly and extendedly dominated points (upper convex hull).
    """
    items = sorted(((int(d), float(c), float(v)) for d, (c, v) in points_by_draw.items()),
                   key=lambda t: (t[1], -t[2]))  # Sort primarily by cost ascending (t[1]),
    # and if two costs are equal, sort the one with higher DALYs first (-t[2]).

    # collapse exact cost ties -> keep the one with max effect
    # The monotone-chain hull expects strictly increasing x (cost).
    # If two rows have (nearly) the same cost, keep only the one with greater DALYs.
    dedup = []
    for t in items:
        if dedup and abs(t[1] - dedup[-1][1]) <= tol:
            if t[2] > dedup[-1][2] + tol:
                dedup[-1] = t
        else:
            dedup.append(t)

    # Calculate the z component or 2D cross product to make sure that the next point involves a right turn
    # (i.e. lower ICER than other subsequent options from the previous point)
    def cross(o, a, b):
        # cross of OA x AB in (x=cost, y=dalys)
        return (a[0]-o[0])*(b[1]-a[1]) - (a[1]-o[1])*(b[0]-a[0])
    # z > 0: the path o→a→b turns left (counter-clockwise).
    # z < 0: it turns right (clockwise)
    # z ≈ 0: the three points are collinear.

    hull = []  # (cost, dalys, draw)
    for d, c, v in dedup:
        p = (c, v, d)
        while len(hull) >= 2:
            o = hull[-2]; a = hull[-1] # These the the two previous points on the hull
            z = cross((o[0], o[1]), (a[0], a[1]), (c, v))
            # For the UPPER hull we keep clockwise turns (z < 0).
            # If z > 0 (concave) or (collinear and we don't include collinear), pop.
            if z > tol or (not include_collinear and abs(z) <= tol):
                hull.pop()
            else:
                break
        hull.append(p)

    draws_on_frontier = [d for (_, _, d) in hull]
    frontier_cd = np.array([(c, v) for (c, v, _) in hull], dtype=float)

    frontier_cd, draws_on_frontier = prune_inward_tail(frontier_cd, draws_on_frontier, tol=1e-9)

    return draws_on_frontier, frontier_cd

def incremental_icers(frontier_cd):
    """Adjacent-segment ICERs along the convex frontier."""
    dc = np.diff(frontier_cd[:, 0])
    dv = np.diff(frontier_cd[:, 1])
    return dc, dv, dc / dv

# Define alternative discount rate sets as a list of dictionaries
alternative_discount_rates = [
    {"discount_rate_cost": 0.03, "discount_rate_health": 0, "discounting_scenario": 'WHO-CHOICE (0.03,0)'},
    {"discount_rate_cost": 0.05, "discount_rate_health": 0.05, "discounting_scenario": 'HAACKER (0.05,0.05)'},
    {"discount_rate_cost": 0.03, "discount_rate_health": 0.03, "discounting_scenario": 'MAIN (0.03,0.03)'}
]

for rates in alternative_discount_rates:
    discount_rate_cost = rates["discount_rate_cost"]
    discount_rate_health = rates["discount_rate_health"]
    # Set figuresoath specific to discounting scenario
    figurespath = main_figurespath / rates["discounting_scenario"]
    if not os.path.exists(figurespath):
        os.makedirs(figurespath)

    print(f"NOW RUNNING SCENARIO {rates['discounting_scenario']}...")

    # %%
    # Estimate standard input costs of scenario
    # -----------------------------------------------------------------------------------------------------------------------
    input_costs = estimate_input_cost_of_scenarios(results_folder, resourcefilepath,
                                                   _years=list_of_relevant_years_for_costing, cost_only_used_staff=True,
                                                   _discount_rate=discount_rate_cost,
                                                   _draws=list(all_manuscript_scenarios.keys()))


    # Add additional costs pertaining to simulation (Only for scenarios with Malaria scale-up)
    # -----------------------------------------------------------------------------------------------------------------------
    def estimate_malaria_scale_up_costs(_params, _relevant_period_for_costing):
        # Load health spending projections
        unit_costs = load_unit_cost_assumptions(resourcefilepath)
        unit_price_consumable = unit_costs["consumables"]

        # Read parameters for consumables costs
        # Load consumables cost data
        unit_price_consumable = unit_price_consumable[unit_price_consumable['Item_Code'].notna()]

        # In this case malaria intervention scale-up costs were not included in the standard estimate_input_cost_of_scenarios function
        list_of_draws_with_malaria_scaleup_parameters = _params[(_params.module_param == 'Malaria:scaleup_start_year')]
        list_of_draws_with_malaria_scaleup_parameters.loc[:, 'value'] = pd.to_numeric(
            list_of_draws_with_malaria_scaleup_parameters['value'])
        list_of_draws_with_malaria_scaleup_implemented_in_costing_period = \
        list_of_draws_with_malaria_scaleup_parameters[(list_of_draws_with_malaria_scaleup_parameters['value'] < max(
            _relevant_period_for_costing))].index.to_list()

        # 1. IRS costs
        irs_coverage_rate = 0.8
        districts_with_irs_scaleup = ['Kasungu', 'Mchinji', 'Lilongwe', 'Lilongwe City', 'Dowa', 'Ntchisi', 'Salima',
                                      'Mangochi',
                                      'Mwanza', 'Likoma', 'Nkhotakota']
        # Convert above list of district names to numeric district identifiers
        district_keys_with_irs_scaleup = [key for key, name in district_dict.items() if
                                          name in districts_with_irs_scaleup]
        year_of_malaria_scaleup_start = \
        list_of_draws_with_malaria_scaleup_parameters.loc[:, 'value'].reset_index()['value'][0]
        final_year_for_costing = max(list_of_relevant_years_for_costing)
        TARGET_PERIOD_MALARIA_SCALEUP = (
        Date(year_of_malaria_scaleup_start, 1, 1), Date(final_year_for_costing, 12, 31))

        # Get population by district
        def get_total_population_by_year(_df):
            years_needed = [i.year for i in TARGET_PERIOD_MALARIA_SCALEUP]  # Malaria scale-up period years
            _df['year'] = pd.to_datetime(_df['date']).dt.year

            # Validate that all necessary years are in the DataFrame
            if not set(years_needed).issubset(_df['year'].unique()):
                raise ValueError("Some years are not recorded in the dataset.")

            # Filter for relevant years and return the total population as a Series
            return \
            _df.loc[_df['year'].between(min(years_needed), max(years_needed)), ['year', 'total']].set_index('year')[
                'total']

        # Get total population by year
        total_population_by_year = extract_results(
            results_folder,
            module='tlo.methods.demography',
            key='population',
            custom_generate_series=get_total_population_by_year,
            do_scaling=True
        )

        def estimate_district_population_from_total(_df):
            """ Generate district population by year from national population by year estimates"""
            # Replicate population estimates for each district
            district_ids = list(range(32))
            df_replicated_for_each_district = pd.concat([_df] * 32, axis=0)
            df_replicated_for_each_district['District_Num'] = np.array(
                sorted(district_ids * (final_year_for_costing - year_of_malaria_scaleup_start + 1)),
                dtype=np.int64)  # attach district number to each replicate
            df_replicated_for_each_district = df_replicated_for_each_district.reset_index()
            df_replicated_for_each_district = df_replicated_for_each_district.sort_index(axis=1)

            # Load proportional population distribution by district
            population_2010 = pd.read_csv(resourcefilepath / 'demography' / 'ResourceFile_Population_2010.csv')
            population_proportion_by_district_2010 = (
                population_2010.groupby('District_Num')['Count']
                .sum()
                .pipe(lambda x: x / x.sum())  # Compute proportions
            )
            assert (population_proportion_by_district_2010.sum() == 1)
            population_proportion_by_district_2010 = population_proportion_by_district_2010.reset_index()
            population_proportion_by_district_2010.columns = pd.MultiIndex.from_tuples(
                [('District_Num', ''), ('Count', '')]
            )
            population_proportion_by_district_2010 = population_proportion_by_district_2010.sort_index(axis=1)

            # Merge and compute district-level population by year
            df_by_district = df_replicated_for_each_district.merge(population_proportion_by_district_2010,
                                                                   on='District_Num', how='left', validate='m:1')
            df_by_district[_df.columns] = df_by_district[
                _df.columns].multiply(df_by_district['Count'], axis=0)
            df_by_district = df_by_district.sort_index(axis=1).drop(columns=['Count'])

            # Set multi-level columns and final formatting
            df_by_district = (
                df_by_district
                .set_axis(pd.MultiIndex.from_tuples(df_by_district.columns, names=['draw', 'run']), axis=1)
                .rename(columns={'District_Num': 'district'})
                .set_index(['year', 'district'])
            )
            df_by_district.columns = pd.MultiIndex.from_tuples(df_by_district.columns)
            df_by_district.columns.names = ['draw', 'run']
            return df_by_district

        # Get population by district by year
        district_population_by_year = estimate_district_population_from_total(total_population_by_year)

        def get_number_of_people_covered_by_malaria_scaleup(_df, list_of_districts_covered=None, draws_included=None):
            _df = pd.DataFrame(_df)
            # Reset the index to make 'district' a column
            _df = _df.reset_index()
            # Convert the 'district' column to numeric values
            _df['district'] = pd.to_numeric(_df['district'], errors='coerce')
            _df = _df.set_index(['year', 'district'])
            # Zero out rows for districts not in the specified list
            if list_of_districts_covered is not None:
                mask = _df.index.get_level_values('district').isin(list_of_districts_covered)
                _df.loc[~mask, :] = 0  # Use mask to zero out unwanted rows

            # Zero out columns for draws not in the specified list
            if draws_included is not None:
                mask = _df.columns.get_level_values('draw').isin(draws_included)
                _df.loc[:, ~mask] = 0  # Use mask to zero out unwanted columns
            return _df

        # Get population by district by year covered by IRS
        district_population_covered_by_irs_scaleup_by_year = get_number_of_people_covered_by_malaria_scaleup(
            district_population_by_year,
            list_of_districts_covered=district_keys_with_irs_scaleup,
            draws_included=list_of_draws_with_malaria_scaleup_implemented_in_costing_period)

        # Get annual cost of IRS under malaria scale-up assumptions
        irs_cost_per_person = unit_price_consumable[unit_price_consumable.Item_Code == 161]['Price_per_unit']
        # This cost includes non-consumable costs - personnel, equipment, fuel, logistics and planning, shipping, PPE. The cost is measured per person protected. Based on Stelmach et al (2018)
        irs_multiplication_factor = irs_cost_per_person * irs_coverage_rate
        total_irs_cost = irs_multiplication_factor.iloc[
                             0] * district_population_covered_by_irs_scaleup_by_year  # for districts and scenarios included
        total_irs_cost = total_irs_cost.groupby(level='year').sum()

        # 2. Bednet costs
        bednet_coverage_rate = 0.7
        # We can assume 3-year lifespan of a bednet, each bednet covering 1.8 people.
        inflation_2011_to_2023 = 1.35
        unit_cost_of_bednet = unit_price_consumable[unit_price_consumable.Item_Code == 160]['Price_per_unit'] + (
                8.27 - 3.36) * inflation_2011_to_2023
        # Stelmach et al Tanzania https://pmc.ncbi.nlm.nih.gov/articles/PMC6169190/#_ad93_ (Price in 2011 USD) - This cost includes non-consumable costs - personnel, equipment, fuel, logistics and planning, shipping. The cost is measured per net distributed
        # Note that the cost per net of $3.36 has been replaced with a cost of Malawi Kwacha 667 (2023) as per the Central Medical Stores Trust sales catalogue

        # We add supply chain costs (procurement + distribution + warehousing) because the unit_cost does not include this
        annual_bednet_cost_per_person = unit_cost_of_bednet / 1.8 / 3
        bednet_multiplication_factor = bednet_coverage_rate * annual_bednet_cost_per_person

        district_population_covered_by_bednet_scaleup_by_year = get_number_of_people_covered_by_malaria_scaleup(
            district_population_by_year,
            draws_included=list_of_draws_with_malaria_scaleup_implemented_in_costing_period)  # All districts covered

        total_bednet_cost = bednet_multiplication_factor.iloc[
                                0] * district_population_covered_by_bednet_scaleup_by_year  # for scenarios included
        total_bednet_cost = total_bednet_cost.groupby(level='year').sum()

        # Malaria scale-up costs - TOTAL
        malaria_scaleup_costs = [
            (total_irs_cost.reset_index(), 'cost_of_IRS_scaleup'),
            (total_bednet_cost.reset_index(), 'cost_of_bednet_scaleup'),
        ]
        return malaria_scaleup_costs


    print("Appending malaria scale-up costs")
    malaria_scaleup_costs = estimate_malaria_scale_up_costs(_params=params,
                                                            _relevant_period_for_costing=relevant_period_for_costing)


    def append_malaria_scale_up_costs_to_total_input_costs(_malaria_scale_up_costs, _total_input_costs,
                                                           _relevant_period_for_costing):
        # Re-format malaria scale-up costs to append to the rest of the input_costs
        def melt_and_label_malaria_scaleup_cost(_df, label):
            multi_index = pd.MultiIndex.from_tuples(_df.columns)
            _df.columns = multi_index

            # reshape dataframe and assign 'draw' and 'run' as the correct column headers
            melted_df = pd.melt(_df, id_vars=['year']).rename(columns={'variable_0': 'draw', 'variable_1': 'run'})
            # Replace item_code with consumable_name_tlo
            melted_df['cost_subcategory'] = label
            melted_df['cost_category'] = 'malaria scale-up'
            melted_df['cost_subgroup'] = 'NA'
            melted_df['Facility_Level'] = 'all'
            melted_df = melted_df.rename(columns={'value': 'cost'})
            return melted_df

        # Iterate through additional costs, melt and concatenate
        for df, label in _malaria_scale_up_costs:
            new_df = melt_and_label_malaria_scaleup_cost(df, label)
            list_of_relevant_years_for_costing = list(
                range(_relevant_period_for_costing[0], _relevant_period_for_costing[1] + 1))
            new_df = new_df[new_df['year'].isin(list_of_relevant_years_for_costing)]
            new_df = apply_discounting_to_cost_data(new_df, _discount_rate=discount_rate_cost,
                                                    _initial_year=_relevant_period_for_costing[0])
            _total_input_costs = pd.concat([_total_input_costs, new_df], ignore_index=True)

        return _total_input_costs


    # Update input costs to include malaria scale up costs
    input_costs = append_malaria_scale_up_costs_to_total_input_costs(_malaria_scale_up_costs=malaria_scaleup_costs,
                                                                     _total_input_costs=input_costs,
                                                                     _relevant_period_for_costing=relevant_period_for_costing)

    input_costs = input_costs.groupby(['draw', 'run', 'year', 'cost_subcategory', 'Facility_Level',
                                       'cost_subgroup', 'cost_category'])['cost'].sum().reset_index()

    # Keep costs for relevant draws
    input_costs = input_costs[input_costs['draw'].isin(list(all_manuscript_scenarios.keys()))]
    # Extract input_costs for browsing
    #input_costs.groupby(['draw', 'run', 'cost_category', 'cost_subcategory', 'cost_subgroup','year'])['cost'].sum().to_csv(figurespath / 'cost_detailed.csv')

    # %%
    # Return on Invesment analysis
    # 1. Calculate incremental cost
    # -----------------------------------------------------------------------------------------------------------------------
    total_input_cost = input_costs.groupby(['draw', 'run'])['cost'].sum()
    total_input_cost_summarized = summarize_cost_data(total_input_cost.unstack(level='run'), _metric=chosen_metric)


    def find_difference_relative_to_comparison(_ser: pd.Series,
                                               comparison: str,
                                               scaled: bool = False,
                                               drop_comparison: bool = True,
                                               ):
        """Find the difference in the values in a pd.Series with a multi-index, between the draws (level 0)
        within the runs (level 1), relative to where draw = `comparison`.
        The comparison is `X - COMPARISON`."""
        return _ser \
            .unstack(level=0) \
            .apply(lambda x: (x - x[comparison]) / (x[comparison] if scaled else 1.0), axis=1) \
            .drop(columns=([comparison] if drop_comparison else [])) \
            .stack()


    incremental_scenario_cost = (pd.DataFrame(
        find_difference_relative_to_comparison(
            total_input_cost,
            comparison=0)  # sets the comparator to draw 0 which is the Actual scenario
    ).T.iloc[0].unstack()).T
    incremental_scenario_cost_subset_for_figure = incremental_scenario_cost[
        incremental_scenario_cost.index.get_level_values('draw').isin(list(main_manuscript_scenarios.keys()))]
    incremental_scenario_cost_summarised = summarize_cost_data(incremental_scenario_cost_subset_for_figure,
                                                               _metric=chosen_metric)


    # 2. Monetary value of health impact
    # -----------------------------------------------------------------------------------------------------------------------
    def get_num_dalys(_df):
        """Return total number of DALYS (Stacked) by label (total within the TARGET_PERIOD).
        Throw error if not a record for every year in the TARGET PERIOD (to guard against inadvertently using
        results from runs that crashed mid-way through the simulation.
        """
        years_needed = relevant_period_for_costing
        assert set(_df.year.unique()).issuperset(years_needed), "Some years are not recorded."
        _df = _df.loc[_df.year.between(*years_needed)].drop(columns=['date', 'sex', 'age_range']).groupby(
            'year').sum().sum(axis=1)

        # Initial year and discount rate
        initial_year = min(_df.index.unique())

        # Calculate the discounted values
        discounted_values = _df / (1 + discount_rate_health) ** (_df.index - initial_year)

        return pd.Series(discounted_values.sum())


    num_dalys = extract_results(
        results_folder,
        module='tlo.methods.healthburden',
        key='dalys_stacked',
        custom_generate_series=get_num_dalys,
        do_scaling=True
    )

    # Get absolute DALYs averted
    num_dalys_averted = (-1.0 *
                         pd.DataFrame(
                             find_difference_relative_to_comparison(
                                 num_dalys.loc[0],
                                 comparison=0)  # sets the comparator to 0 which is the Actual scenario
                         ).T.iloc[0].unstack(level='run'))
    num_dalys_averted = num_dalys_averted[num_dalys_averted.index.get_level_values('draw').isin(
        list(all_manuscript_scenarios.keys()))]  # keep only relevant draws

    # Plot DALYs
    num_dalys_averted_subset_for_figure = num_dalys_averted[
        num_dalys_averted.index.get_level_values('draw').isin(list(main_manuscript_scenarios.keys()))]
    num_dalys_averted_summarised = summarize_cost_data(num_dalys_averted_subset_for_figure, _metric=chosen_metric)
    name_of_plot = f'Incremental DALYs averted compared to baseline {relevant_period_for_costing[0]}-{relevant_period_for_costing[1]}'
    fig, ax = do_standard_bar_plot_with_ci(
        (num_dalys_averted_summarised / 1e6),
        annotations=[
            f"{row['median'] / 1e6:.2f} ({row['lower'] / 1e6 :.2f}- {row['upper'] / 1e6:.2f})"
            for _, row in num_dalys_averted_summarised.iterrows()
        ],
        xticklabels_horizontal_and_wrapped=False,
        put_labels_in_legend=True,
        offset=2,
    )
    ax.set_title(name_of_plot)
    ax.set_ylabel('DALYs \n(Millions)')
    ax.set_ylim(bottom=0)
    fig.tight_layout()
    fig.savefig(figurespath / name_of_plot.replace(' ', '_').replace(',', ''))
    plt.close(fig)


    # The monetary value of the health benefit is delta health times CET (negative values are set to 0)
    def get_monetary_value_of_incremental_health(_num_dalys_averted, _chosen_value_of_life_year):
        monetary_value_of_incremental_health = (_num_dalys_averted * _chosen_value_of_life_year).clip(lower=0.0)
        return monetary_value_of_incremental_health


    # 3. Estimate and plot ICERs
    # ----------------------------------------------------
    icers = incremental_scenario_cost.div(num_dalys_averted)  # Element-wise division
    # icers = icers.mask(num_dalys_averted < 0)
    icers_summarized = summarize_cost_data(icers, _metric=chosen_metric)
    dominated_scenarios = icers_summarized['median'] < 0
    icers_summarized[dominated_scenarios] = np.nan  # The dominanted scenarios are assigned as ICER of NaN
    icers_summarized_subset_for_figure = icers_summarized[
        icers_summarized.index.get_level_values('draw').isin(list(main_manuscript_scenarios.keys()))]

    # Plot ICERs
    annotations_icers = []
    for _, row in icers_summarized_subset_for_figure.iterrows():
        if not any(pd.isna(row[[chosen_metric, 'lower', 'upper']])) and np.isfinite(row[chosen_metric]):
            annotations_icers.append(f"{row[chosen_metric]:.2f} ({row['lower']:.2f}-\n{row['upper']:.2f})")
        elif pd.isna(row['median']):  # or chosen_metric if that's 'median'
            annotations_icers.append("Dominated")
        else:
            annotations_icers.append("")

    for stat in ['median', 'lower', 'upper']:
        icers_summarized_subset_for_figure.loc[icers_summarized_subset_for_figure[stat].isna(), stat] = 0.1
    name_of_plot = f'Incremental cost-effectiveness ratios (ICERs), {relevant_period_for_costing[0]}-{relevant_period_for_costing[1]}'
    fig, ax = do_standard_bar_plot_with_ci(
        (icers_summarized_subset_for_figure),
        annotations=annotations_icers,
        xticklabels_horizontal_and_wrapped=False,
        put_labels_in_legend=True,
        offset=10,
    )
    ax.set_title(name_of_plot)
    ax.set_ylabel('ICERs \n($/DALY averted)')
    ax.set_ylim(bottom=0)
    fig.tight_layout()
    fig.savefig(figurespath / name_of_plot.replace(' ', '_').replace(',', ''))
    plt.close(fig)

    # Extract ICERs into a table for manuscript
    icers_summarized_subset_for_table = icers_summarized[
        icers_summarized.index.get_level_values('draw').isin(list(all_manuscript_scenarios.keys()))]
    icers_summarized_subset_for_table = icers_summarized_subset_for_table.reset_index()
    icers_summarized_subset_for_table['scenario'] = icers_summarized_subset_for_table['draw'].map(
        all_manuscript_scenarios)
    icers_summarized_subset_for_table['ICER (2023 USD)'] = icers_summarized_subset_for_table.apply(
        lambda
            row: "Dominated"  # if incremental health is negative, the scenario is dominated - reporting a negative ICER can be confusing
        if row['median'] < 0 else (
            f"${row['median']:.2f} [${row['lower']:.2f} - ${row['upper']:.2f}]"
            if not any(pd.isna(row[['median', 'lower', 'upper']])) else "Dominated"
        ),
        axis=1
    )
    icers_summarized_subset_for_table[['scenario', 'ICER (2023 USD)']].to_csv(figurespath / 'tabulated_icers.csv',
                                                                              index=False)

    # Create a lookup from draw to formatted ICER string
    icer_lookup = dict(zip(
        icers_summarized_subset_for_table['draw'],
        icers_summarized_subset_for_table['ICER (2023 USD)']
    ))


    # Plot incremental health and cost in a scatterplot
    # ----------------------------------------------------
    def do_incremental_cost_and_health_plot(incremental_cost_df,
                                            incremental_dalys_df,
                                            figname,
                                            draws_with_icer_labels: Optional[list[int]] = None,
                                            horizontal_scenarios: Optional[list[int]] = None,
                                            vertical_scenarios: Optional[list[int]] = None,
                                            diagonal_scenarios: Optional[list[int]] = None,
                                            scenario_dict: Optional[dict[int, str]] = None,
                                            # NEW frontier options
                                            overlay_frontier: bool = True,
                                            plot_icers_on_frontier: bool = False,
                                            icer_lookup: Optional[dict[int, str]] = None,
                                            # needs to be provided if plot_icers_on_frontier = True
                                            frontier_color: str = "black",
                                            frontier_linewidth: float = 2.0,
                                            legend_position: Literal['inset', 'offset'] = "offset"):

        # Define colors for high level grouping of scenarios
        color_map_scatter = {"HSS Investments": "#9e0142", "HTM-focussed Investments": "#fdae61",
                             "Combined Investments": "#66c2a5"}
        horizontal_scenarios = horizontal_scenarios
        vertical_scenarios = vertical_scenarios
        diagonal_scenarios = diagonal_scenarios
        # Draws to highlight, if any
        darker_draws = draws_with_icer_labels
        darker_set = set(darker_draws)

        # Reorder
        new_order = horizontal_scenarios + vertical_scenarios + diagonal_scenarios
        incremental_dalys_df = incremental_dalys_df.loc[new_order]
        incremental_cost_df = incremental_cost_df.loc[new_order]

        # NUMERIC labels 1..N (based on the plotting order above)
        scenario_labels = {draw: str(i + 1) for i, draw in enumerate(incremental_dalys_df.index)}

        # Extract stats for axes
        x_median = incremental_dalys_df['median'] / 1e6
        x_lower = incremental_dalys_df['lower'] / 1e6
        x_upper = incremental_dalys_df['upper'] / 1e6
        y_median = incremental_cost_df['median']
        y_lower = incremental_cost_df['lower']
        y_upper = incremental_cost_df['upper']

        fig, ax = plt.subplots(figsize=(16, 9))
        texts = []

        # Scatter + error bars + numeric tiles
        for draw in incremental_dalys_df.index:
            if draw in horizontal_scenarios:
                color = color_map_scatter["HSS Investments"]
            elif draw in vertical_scenarios:
                color = color_map_scatter["HTM-focussed Investments"]
            elif draw in diagonal_scenarios:
                color = color_map_scatter["Combined Investments"]
            else:
                color = "gray"

            is_darker = draw in darker_set

            # Plot the central values
            ax.scatter(x_median[draw], y_median[draw],
                       s=36, color=color,
                       edgecolor='black' if is_darker else 'none',
                       linewidth=2.0 if is_darker else 0.0, zorder=3)

            # Plot the error bars
            ax.errorbar(x_median[draw], y_median[draw],
                        xerr=[[x_median[draw] - x_lower[draw]], [x_upper[draw] - x_median[draw]]],
                        yerr=[[y_median[draw] - y_lower[draw]], [y_upper[draw] - y_median[draw]]],
                        fmt='none', color=color, alpha=0.6, capsize=4, elinewidth=1, zorder=2)

            # Add number labels above the dots
            texts.append(
                ax.text(x_median[draw], y_median[draw] + 1e7,
                        scenario_labels[draw],
                        fontsize=12, ha='center', va='bottom', color='white', weight='bold',
                        bbox=dict(facecolor=color, edgecolor='none', boxstyle='round,pad=0.3', alpha=0.9),
                        zorder=4)
            )

            # If this draw should show ICER, add it below the dot
            if draws_with_icer_labels and draw in draws_with_icer_labels:
                icer_text = icer_lookup.get(draw, "")
                texts.append(ax.text(
                    x_median[draw] + 0.5, y_median[draw] + 0.1,
                    f"$ICER_{{{scenario_labels[draw]}}} =$\n{icer_text}",
                    fontsize=12, weight='bold', ha='center', va='top', color='black', zorder=4
                ))

        if texts:
            adjust_text(texts, arrowprops=dict(arrowstyle='->'))

        # --- Frontier overlay (upper convex hull in (cost, dalys) vs baseline) ---
        if overlay_frontier:
            # Build dict in (cost, dalys) using *medians vs baseline*
            points_by_draw = {
                int(d): (float(y_median[d]), float(x_median[d] * 1e6))  # (cost, dalys)
                for d in incremental_dalys_df.index
            }
            # add baseline origin because we're dealing with incremental costs
            points_by_draw.setdefault(0, (0.0, 0.0))

            frontier_draws, frontier_cd = upper_convex_frontier_from_dict(points_by_draw, include_collinear=False)

            # convert for plotting on scaled axes (x=DALYs millions, y=cost billions)
            fx = frontier_cd[:, 1] / 1e6
            fy = frontier_cd[:, 0]
            (frontier_line,) = ax.plot(fx, fy, '-', lw=frontier_linewidth,
                                       color=frontier_color, label='Frontier (median)', zorder=5)
            ax.scatter(fx, fy, s=24, facecolors='white', edgecolors=frontier_color,
                       linewidths=1.5, zorder=6)

            if plot_icers_on_frontier and len(frontier_cd) >= 2:
                dc, dv, icers = incremental_icers(frontier_cd)
                for i in range(len(icers)):
                    mx = (fx[i] + fx[i + 1]) / 2
                    my = (fy[i] + fy[i + 1]) / 2 + 0.7
                    ax.text(mx, my, f"ICER = ${icers[i]:.2f} \nper DALY averted", fontsize=7, ha='center', va='bottom',
                            color='black',
                            bbox=dict(
                                facecolor='white',  # background color
                                edgecolor=frontier_color,
                                boxstyle='round,pad=0.2',
                                linewidth=0.8,
                                alpha=0.9
                            ),
                            zorder=10)

        # --- Legend using numeric labels ---
        legend_labels, dummy_handles = [], []
        scenario_categories = {
            "HSS Investments": horizontal_scenarios,
            "HTM-focussed Investments": vertical_scenarios,
            "Combined Investments": diagonal_scenarios
        }
        for category, draws in scenario_categories.items():
            legend_labels.append(category)
            dummy_handles.append(mpatches.Patch(color="white", label=""))
            for draw in draws:
                scenario_name = scenario_dict.get(draw, f"Scenario {draw}")
                color = (color_map_scatter["HSS Investments"] if draw in horizontal_scenarios else
                         color_map_scatter["HTM-focussed Investments"] if draw in vertical_scenarios else
                         color_map_scatter["Combined Investments"] if draw in diagonal_scenarios else "gray")
                is_darker = draw in darker_set
                legend_labels.append(f"{scenario_labels[draw]}: {scenario_name}")
                dummy_handles.append(
                    plt.Line2D([0], [0], marker='o', color='w',
                               markerfacecolor=color, markeredgecolor='black' if is_darker else 'none',
                               markersize=8, markeredgewidth=2 if is_darker else 0)
                )

        if (legend_position == "inset"):
            bbox_to_anchor = (0, 1)
        elif (legend_position == "offset"):
            bbox_to_anchor = (1.1, 1)
        else:
            bbox_to_anchor = (0, 1)

        ax.legend(dummy_handles, legend_labels, bbox_to_anchor=bbox_to_anchor, loc='upper left', fontsize=9.2,
                  title="Scenario Key", frameon=True)

        ax.set_xlabel("DALYs Averted, millions")
        ax.set_ylabel("Incremental Scenario Cost, billions (USD)")
        ax.grid(True)
        fig.tight_layout()
        plt.savefig(figurespath / figname, dpi=300)
        plt.close(fig)


    do_incremental_cost_and_health_plot(incremental_cost_df=summarize_cost_data(incremental_scenario_cost, chosen_metric),
                                        incremental_dalys_df=summarize_cost_data(num_dalys_averted, chosen_metric),
                                        draws_with_icer_labels=[1],
                                        horizontal_scenarios=[2, 4, 7],
                                        vertical_scenarios=[8, 16, 24, 32, 40, 44, 48],
                                        diagonal_scenarios=[10, 12, 15,
                                                            18, 20, 23,
                                                            26, 28, 31,
                                                            34, 36, 39,
                                                            41, 42, 43, 45, 46, 47, 49, 50, 51],
                                        plot_icers_on_frontier=True,
                                        scenario_dict=all_manuscript_scenarios,
                                        figname='cea_plane_frontier.png',
                                        icer_lookup=icer_lookup,
                                        overlay_frontier=True,
                                        legend_position="offset")

    do_incremental_cost_and_health_plot(incremental_cost_df=summarize_cost_data(incremental_scenario_cost, chosen_metric),
                                        incremental_dalys_df=summarize_cost_data(num_dalys_averted, chosen_metric),
                                        draws_with_icer_labels=[7, 32, 39],
                                        horizontal_scenarios=[1, 2, 3, 4, 5, 6, 7],
                                        vertical_scenarios=[8, 16, 24, 32],
                                        diagonal_scenarios=[15, 23, 31, 39],
                                        scenario_dict=all_manuscript_scenarios,
                                        figname='cea_plane.png',
                                        icer_lookup=icer_lookup,
                                        overlay_frontier=False,
                                        legend_position="inset")

    # 4. Return on Investment
    # ----------------------------------------------------
    # Estimate projected health spending
    projected_health_spending = estimate_projected_health_spending(resourcefilepath,
                                                                   results_folder,
                                                                   _years=list_of_relevant_years_for_costing,
                                                                   _discount_rate=discount_rate_cost,
                                                                   _summarize=True,
                                                                   _metric=chosen_metric)
    projected_health_spending_baseline = \
    projected_health_spending[projected_health_spending.index.get_level_values(0) == 0][chosen_metric][0]


    # Extract projected health spending table for appendix
    def get_manuscript_ready_table_of_projected_health_spending(_relevant_period_for_costing):
        def get_total_population_by_year(_df):
            years_needed = _relevant_period_for_costing  # Malaria scale-up period years
            _df['year'] = pd.to_datetime(_df['date']).dt.year

            # Validate that all necessary years are in the DataFrame
            if not set(years_needed).issubset(_df['year'].unique()):
                raise ValueError("Some years are not recorded in the dataset.")

            # Filter for relevant years and return the total population as a Series
            return \
            _df.loc[_df['year'].between(min(years_needed), max(years_needed)), ['year', 'total']].set_index('year')[
                'total']

        # Get total population by year
        total_population_by_year = extract_results(
            results_folder,
            module='tlo.methods.demography',
            key='population',
            custom_generate_series=get_total_population_by_year,
            do_scaling=True
        ).unstack().reset_index().rename(columns={0: 'population'})
        total_population_summary = total_population_by_year[total_population_by_year.draw == 0].groupby("year")[
            "population"].agg(
            population="median"
        ).reset_index()
        unit_costs = load_unit_cost_assumptions(resourcefilepath)
        health_spending_per_capita = unit_costs["health_spending_projections"]
        health_spending_per_capita = health_spending_per_capita[health_spending_per_capita.year.isin(
            list(range(_relevant_period_for_costing[0], _relevant_period_for_costing[1] + 1)))]
        health_spending_per_capita = health_spending_per_capita[['year', 'total_mean']].apply(
            pd.to_numeric, errors='coerce')
        health_spending_per_capita_table = health_spending_per_capita.merge(total_population_summary, on="year",
                                                                            how="left", validate="1:1")
        health_spending_per_capita_table["total_health_spending"] = health_spending_per_capita_table['total_mean'] * \
                                                                    health_spending_per_capita_table['population']
        return health_spending_per_capita_table


    health_spending_per_capita_table = get_manuscript_ready_table_of_projected_health_spending(
        _relevant_period_for_costing=relevant_period_for_costing)
    health_spending_per_capita_table.to_csv(figurespath / 'projected_health_spending.csv', index=False)

    # Combined ROI plot of relevant scenarios
    # ROI plot comparing HSS alone, HTM without HSS, and HTM with HSS
    if rates["discounting_scenario"] == 'MAIN (0.03,0.03)':
        legend_switch_for_main_roi_plot = False  # Don't show legend for main plot
    else:
        legend_switch_for_main_roi_plot = True


    # Convert results to dictionary to write text extracts for manuscript
    def convert_results_to_dict(_df):
        draws = _df.index.to_list()
        values = {
            draw: {
                chosen_metric: _df.loc[_df.index.get_level_values('draw') == draw, chosen_metric].iloc[0],
                "lower": _df.loc[_df.index.get_level_values('draw') == draw, 'lower'].iloc[0],
                "upper": _df.loc[_df.index.get_level_values('draw') == draw, 'upper'].iloc[0]
            }
            for draw in draws
        }
        return values


    # Do ROI plots for different VSLY values
    i = 0
    vsly_fig_suffixes = ['LOWER', 'UPPER', 'MAIN']
    for vsly in [chosen_value_of_statistical_life_lower, chosen_value_of_statistical_life_upper,
                 chosen_value_of_statistical_life]:
        # ROI at 0 implementation costs
        benefit_at_0_implementation_cost = get_monetary_value_of_incremental_health(num_dalys_averted,
                                                                                    vsly) - incremental_scenario_cost
        roi_at_0_implementation_cost = benefit_at_0_implementation_cost.div(abs(incremental_scenario_cost))
        roi_at_0_implementation_cost_summarized = summarize_cost_data(roi_at_0_implementation_cost,
                                                                      _metric=chosen_metric)
        roi_at_0_implementation_cost_dict = convert_results_to_dict(roi_at_0_implementation_cost_summarized)

        # health_benefit_summarised = convert_results_to_dict(summarize_cost_data(
        # get_monetary_value_of_incremental_health(num_dalys_averted, vsly),
        # _metric=chosen_metric))
        # incremental_scenario_cost_summarised = convert_results_to_dict(
        #     summarize_cost_data(incremental_scenario_cost, _metric=chosen_metric))

        # ROI at implementation costs = 138% of input costs
        implementation_cost_upper_limit = incremental_scenario_cost * above_service_level_cost_proportion
        implementation_cost_upper_limit_dict = convert_results_to_dict(
            summarize_cost_data(implementation_cost_upper_limit,
                                _metric=chosen_metric))
        benefit_at_upper_limit_implementation_cost = (get_monetary_value_of_incremental_health(num_dalys_averted,
                                                                                               vsly)
                                                      - incremental_scenario_cost
                                                      - implementation_cost_upper_limit)
        roi_at_upper_limit_implementation_cost = benefit_at_0_implementation_cost.div(
            abs(incremental_scenario_cost + implementation_cost_upper_limit))
        roi_at_upper_limit_implementation_cost_dict = convert_results_to_dict(
            summarize_cost_data(roi_at_upper_limit_implementation_cost, _metric=chosen_metric))


        # Create a function to generate threshold (or maximum) implementation costs which the scneario with the higher ROI
        # can incur over and above those incurred by the scenario with the lower ROI while still delivering a higher ROI
        def compute_breakeven_with_ci(
            roi_df: pd.DataFrame,
            monetary_benefit_df: pd.DataFrame,
            incremental_cost_df: pd.DataFrame,
            implementation_cost_df: pd.DataFrame,
            draw_target: int,
            draw_compare: int
        ):
            """
            Compute breakeven implementation costs across runs and return median and 95% CI.

            Parameters:
            -----------
            roi_df : pd.DataFrame
                ROI DataFrame with index as (draw) and columns as runs.
            monetary_benefit_df : pd.DataFrame
                Monetised health benefits with same structure as roi_df.
            incremental_cost_df : pd.DataFrame
                Incremental input cost with same structure.

            draw_target : int
                The draw index for the target scenario.

            draw_compare : int
                The draw index for the scenario used to compute the threshold (e.g., vertical or HSS).

            Returns:
            --------
            str
                A label string in the format "$XXXM [$XX–$XXM]"
            """

            values = []
            for run in roi_df.columns:
                roi_val = roi_df.loc[draw_compare, run]
                health_benefit = monetary_benefit_df.loc[draw_target, run]
                cost = incremental_cost_df.loc[draw_target, run]

                # Breakeven formula
                val = (health_benefit - cost * (roi_val + 1)) / (roi_val + 1)
                val = val - implementation_cost_df.loc[draw_compare, run]
                values.append(val)

            values = np.array(values) / 1e6  # Convert to millions
            median, lower, upper = np.median(values), np.percentile(values, 2.5), np.percentile(values, 97.5)

            # estimate median point on the ROI curves for the figure
            roi_summary = convert_results_to_dict(summarize_cost_data(roi_df, chosen_metric))
            health_summary = convert_results_to_dict(summarize_cost_data(monetary_benefit_df, chosen_metric))
            cost_summary = convert_results_to_dict(summarize_cost_data(incremental_cost_df, chosen_metric))
            breakeven_central_value = (health_summary[draw_target][chosen_metric] - cost_summary[draw_target][
                chosen_metric] * (roi_summary[draw_compare][chosen_metric] + 1)) / (
                                          roi_summary[draw_compare][chosen_metric] + 1)
            breakeven_central_value = breakeven_central_value / 1e6

            return median, lower, upper, breakeven_central_value


        # Breakeven implementation cost for joint HTM diagonal scenario (V joint HTM vertical scenario);
        # Implementation cost = 0
        breakeven_lower_v_htm = compute_breakeven_with_ci(
            roi_df=roi_at_0_implementation_cost,
            monetary_benefit_df=get_monetary_value_of_incremental_health(num_dalys_averted, vsly),
            incremental_cost_df=incremental_scenario_cost,
            implementation_cost_df=0 * incremental_scenario_cost,
            draw_target=diagonal_htm,
            draw_compare=vertical_htm
        )
        # Breakeven implementation cost for joint HTM diagonal scenario (V joint HTM vertical scenario);
        # Implementation cost = 138% of Input costs
        breakeven_upper_v_htm = compute_breakeven_with_ci(
            roi_df=roi_at_upper_limit_implementation_cost,
            monetary_benefit_df=get_monetary_value_of_incremental_health(num_dalys_averted, vsly),
            incremental_cost_df=incremental_scenario_cost,
            implementation_cost_df=implementation_cost_upper_limit,
            draw_target=diagonal_htm,
            draw_compare=vertical_htm
        )
        # Breakeven implementation cost for joint HTM diagonal scenario (V horizontal scenario);
        # Implementation cost = 0
        breakeven_lower_v_hss = compute_breakeven_with_ci(
            roi_df=roi_at_0_implementation_cost,
            monetary_benefit_df=get_monetary_value_of_incremental_health(num_dalys_averted, vsly),
            incremental_cost_df=incremental_scenario_cost,
            implementation_cost_df=0 * incremental_scenario_cost,
            draw_target=diagonal_htm,
            draw_compare=horizontal_hss
        )
        # Breakeven implementation cost for joint HTM diagonal scenario (V horizontal scenario);
        # Implementation cost = 138% of Input costs
        breakeven_upper_v_hss = compute_breakeven_with_ci(
            roi_df=roi_at_upper_limit_implementation_cost,
            monetary_benefit_df=get_monetary_value_of_incremental_health(num_dalys_averted, vsly),
            incremental_cost_df=incremental_scenario_cost,
            implementation_cost_df=implementation_cost_upper_limit,
            draw_target=diagonal_htm,
            draw_compare=horizontal_hss
        )

        if (vsly_fig_suffixes[i] == 'MAIN') & (rates["discounting_scenario"] == 'MAIN (0.03,0.03)'):  # The breakeven
            # ASC costs are only plotted in th main results plot
            # Generate data for the representation of breakeven implementation costs on the ROI plots
            additional_horizontal_lines_for_interpretation = [
                {
                    'y_value': roi_at_0_implementation_cost_dict[vertical_htm][chosen_metric],
                    'x_start': 0,
                    'x_end': breakeven_lower_v_htm[0],
                    # where the horizontal line intersects the ROI curve of the diagonal strategy
                    'label': f"a = ${breakeven_lower_v_htm[0]:.0f}M [${breakeven_lower_v_htm[1]:.0f}M–${breakeven_lower_v_htm[2]:.0f}M]",
                    'color': '#fdae61',
                    'scenario_label': 'Diagonal versus Vertical (at ASC = 0)'
                },
                {
                    'y_value': roi_at_upper_limit_implementation_cost_dict[vertical_htm][chosen_metric],
                    'x_start': implementation_cost_upper_limit_dict[vertical_htm][chosen_metric] / 1e6,
                    'x_end': breakeven_upper_v_htm[0],
                    # where the horizontal line intersects the ROI curve of the diagonal strategy
                    'label': f"b = ${breakeven_upper_v_htm[0]:.0f}M [${breakeven_upper_v_htm[1]:.0f}M–${breakeven_upper_v_htm[2]:.0f}M]",
                    'color': '#fdae61',
                    'scenario_label': 'Diagonal versus Vertical (at ASC = 138% X SC)',
                    'y_label_offset': 0.25
                },
                {
                    'y_value': roi_at_0_implementation_cost_dict[horizontal_hss][chosen_metric],
                    'x_start': 0,
                    'x_end': breakeven_lower_v_hss[3],
                    # where the horizontal line intersects the ROI curve of the diagonal strategy
                    'label': f"c = ${breakeven_lower_v_hss[0]:.0f}M [${breakeven_lower_v_hss[1]:.0f}M–${breakeven_lower_v_hss[2]:.0f}M]",
                    'color': '#9e0142',
                    'scenario_label': 'Diagonal versus Horizontal (at ASC = 0)',
                    'y_label_offset': -0.25
                },
                {
                    'y_value': roi_at_upper_limit_implementation_cost_dict[horizontal_hss][chosen_metric],
                    'x_start': implementation_cost_upper_limit_dict[horizontal_hss][chosen_metric] / 1e6,
                    'x_end': breakeven_upper_v_hss[3],
                    # where the horizontal line intersects the ROI curve of the diagonal strategy
                    'label': f"d = ${breakeven_upper_v_hss[0]:.0f}M [${breakeven_upper_v_hss[1]:.0f}M–${breakeven_upper_v_hss[2]:.0f}M]",
                    'color': '#9e0142',
                    'scenario_label': 'Diagonal versus Horizontal (at ASC = 138% X SC)',
                    'y_label_offset': -0.25
                }
            ]
            legend_switch_for_main_roi_plot = False
        else:
            additional_horizontal_lines_for_interpretation = None
            legend_switch_for_main_roi_plot = True

        draw_colors = {horizontal_hss: '#9e0142', vertical_htm: '#fdae61', diagonal_htm: '#66c2a5'}
        generate_multiple_scenarios_roi_plot(
            _monetary_value_of_incremental_health=get_monetary_value_of_incremental_health(num_dalys_averted,
                                                                                           _chosen_value_of_life_year=vsly),
            _incremental_input_cost=incremental_scenario_cost,
            _draws=[horizontal_hss, vertical_htm, diagonal_htm],
            _scenario_dict=all_manuscript_scenarios,
            _outputfilepath=figurespath,
            _value_of_life_suffix=vsly_fig_suffixes[i],
            _metric=chosen_metric,
            _year_suffix=f' ({str(relevant_period_for_costing[0])} - {str(relevant_period_for_costing[1])})',
            _projected_health_spending=projected_health_spending_baseline,
            _additional_horizontal_lines_for_interpretation=None,
            _draw_colors=draw_colors,
            show_title_and_legend=legend_switch_for_main_roi_plot)

        i = i + 1

    incremental_scenario_cost_summarised = convert_results_to_dict(incremental_scenario_cost_summarised)
    print(f"Under an alternative assumption that the vertical approach incurs incremental above service level costs "
          f"equal to 138% of its incremental service level cost (based on estimates from Opuni et al (2023)), "
          f"the diagonal approach provided a higher ROI up to an even higher threshold of "
          f"${breakeven_upper_v_htm[0]: .2f}[${breakeven_upper_v_htm[1]: .2f} - ${breakeven_upper_v_htm[2]: .2f}] million "
          f"incremental above service level costs in comparison with the vertical approach, or equal to "
          f"{(breakeven_upper_v_htm[0] * 1e6) / incremental_scenario_cost_summarised[diagonal_htm][chosen_metric] * 100: .2f}% of its own incremental service level cost")

    # HIV scenarios with and without HSS
    draw_colors = {vertical_hiv: '#fdae61', diagonal_hiv: '#66c2a5'}
    generate_multiple_scenarios_roi_plot(
        _monetary_value_of_incremental_health=get_monetary_value_of_incremental_health(num_dalys_averted,
                                                                                       _chosen_value_of_life_year=chosen_value_of_statistical_life),
        _incremental_input_cost=incremental_scenario_cost,
        _draws=[vertical_hiv, diagonal_hiv],
        _scenario_dict=all_manuscript_scenarios,
        _metric=chosen_metric,
        _outputfilepath=figurespath,
        _year_suffix=f' ({str(relevant_period_for_costing[0])}- {str(relevant_period_for_costing[1])})',
        _value_of_life_suffix='HIV_VSL',
        _draw_colors=draw_colors)

    # TB scenarios with and without HSS
    draw_colors = {vertical_tb: '#fdae61', diagonal_tb: '#66c2a5'}
    generate_multiple_scenarios_roi_plot(
        _monetary_value_of_incremental_health=get_monetary_value_of_incremental_health(num_dalys_averted,
                                                                                       _chosen_value_of_life_year=chosen_value_of_statistical_life),
        _incremental_input_cost=incremental_scenario_cost,
        _draws=[vertical_tb, diagonal_tb],
        _scenario_dict=all_manuscript_scenarios,
        _metric=chosen_metric,
        _outputfilepath=figurespath,
        _year_suffix=f' ({str(relevant_period_for_costing[0])}- {str(relevant_period_for_costing[1])})',
        _value_of_life_suffix='TB_VSL',
        _draw_colors=draw_colors,
        _y_axis_lim=30)

    # Malaria scenarios with and without HSS
    draw_colors = {vertical_malaria: '#fdae61', diagonal_malaria: '#66c2a5'}
    generate_multiple_scenarios_roi_plot(
        _monetary_value_of_incremental_health=get_monetary_value_of_incremental_health(num_dalys_averted,
                                                                                       _chosen_value_of_life_year=chosen_value_of_statistical_life),
        _incremental_input_cost=incremental_scenario_cost,
        _draws=[vertical_malaria, diagonal_malaria],
        _scenario_dict=all_manuscript_scenarios,
        _metric=chosen_metric,
        _outputfilepath=figurespath,
        _year_suffix=f' ({str(relevant_period_for_costing[0])}- {str(relevant_period_for_costing[1])})',
        _value_of_life_suffix='Malaria_VSL',
        _draw_colors=draw_colors)

    # ROI estimates in a table
    roi_table_label = ['MAIN', 'LOWER', 'UPPER']
    i = 0
    for vsly in [chosen_value_of_statistical_life, chosen_value_of_statistical_life_lower,
                 chosen_value_of_statistical_life_upper]:
        roi_table = tabulate_roi_estimates(
            _monetary_value_of_incremental_health=get_monetary_value_of_incremental_health(num_dalys_averted,
                                                                                           _chosen_value_of_life_year=vsly),
            _incremental_input_cost=incremental_scenario_cost,
            _draws=list(all_manuscript_scenarios.keys()),
            _metric='median')

        # Extract ROIs into a table for manuscript
        roi_table['scenario'] = roi_table['draw'].map(all_manuscript_scenarios)
        # Pivot the DataFrame to make 'stat' values columns
        roi_table = roi_table.drop_duplicates(['scenario', 'implementation_cost', 'stat', 'roi'])
        roi_pivot_table = roi_table.pivot(index=['draw', 'scenario', 'implementation_cost'], columns='stat',
                                          values='roi')
        roi_pivot_table = roi_pivot_table.sort_index(level='draw')
        # Format the values as "median [lower - upper]"
        roi_pivot_table['ROI at VSLY = $834'] = roi_pivot_table.apply(
            lambda row: f"{row['median']:.2f} [{row['lower']:.2f} - {row['upper']:.2f}]"
            if not any(pd.isna(row[['median', 'lower', 'upper']])) else "N/A",
            axis=1
        )
        # Reset index to move 'implementation_cost' to columns and reshape for the manuscript
        roi_pivot_table = roi_pivot_table['ROI at VSLY = $834'].unstack(level='implementation_cost')
        roi_pivot_table.columns.name = None  # Remove multi-index column name
        roi_pivot_table.index.name = 'Scenario'
        roi_pivot_table.reset_index().drop(columns='draw').to_csv(
            figurespath / f'tabulated_roi_for_all_implementation_costs_{roi_table_label[i]}.csv', index=False)

        roi_table_small = extract_roi_at_specific_implementation_costs(
            _monetary_value_of_incremental_health=get_monetary_value_of_incremental_health(num_dalys_averted,
                                                                                           _chosen_value_of_life_year=vsly),
            _incremental_input_cost=incremental_scenario_cost,
            _non_zero_implementation_cost_proportion=above_service_level_cost_proportion,
            _draws=list(all_manuscript_scenarios.keys()),
            _metric='median')
        roi_table_small['scenario'] = roi_table_small['draw'].map(all_manuscript_scenarios)
        # Drop 'draw' and move 'scenario' to the first column
        roi_table_small = roi_table_small.drop(columns='draw')
        cols = ['scenario'] + [col for col in roi_table_small.columns if col != 'scenario']
        roi_table_small = roi_table_small[cols]
        roi_table_small.to_csv(figurespath / f'tabulated_roi_for_manuscript_{roi_table_label[i]}.csv', index=False)
        i += 1

    # 5. Plot Maximum ability-to-pay at CET
    # ----------------------------------------------------
    max_ability_to_pay_for_implementation = (get_monetary_value_of_incremental_health(num_dalys_averted,
                                                                                      _chosen_value_of_life_year=chosen_cet) - incremental_scenario_cost).clip(
        lower=0.0)  # monetary value - change in costs
    max_ability_to_pay_for_implementation_subset_for_figure = max_ability_to_pay_for_implementation[
        max_ability_to_pay_for_implementation.index.get_level_values('draw').isin(
            list(main_manuscript_scenarios.keys()))]
    max_ability_to_pay_for_implementation_summarized = summarize_cost_data(
        max_ability_to_pay_for_implementation_subset_for_figure, _metric=chosen_metric)

    # Plot Maximum ability to pay
    name_of_plot = f'Maximum ability to pay at CET, {relevant_period_for_costing[0]}-{relevant_period_for_costing[1]}'
    fig, ax = do_standard_bar_plot_with_ci(
        (max_ability_to_pay_for_implementation_summarized / 1e6),
        annotations=[
            f"{row[chosen_metric] / projected_health_spending_baseline :.2%} ({row['lower'] / projected_health_spending_baseline :.2%}- \n {row['upper'] / projected_health_spending_baseline:.2%})"
            for _, row in max_ability_to_pay_for_implementation_summarized.iterrows()
        ],
        xticklabels_horizontal_and_wrapped=False,
        put_labels_in_legend=True,
        offset=50,
    )
    ax.set_title(name_of_plot)
    ax.set_ylabel('Maximum ability to pay \n(Millions)')
    ax.set_ylim(bottom=0)
    fig.tight_layout()
    fig.savefig(figurespath / name_of_plot.replace(' ', '_').replace(',', ''))
    plt.close(fig)

    # Plot incremental costs
    incremental_scenario_cost_summarized = summarize_cost_data(incremental_scenario_cost_subset_for_figure,
                                                               _metric=chosen_metric)
    name_of_plot = f'Incremental scenario cost relative to baseline {relevant_period_for_costing[0]}-{relevant_period_for_costing[1]}'
    fig, ax = do_standard_bar_plot_with_ci(
        (incremental_scenario_cost_summarized / 1e6),
        annotations=[
            f"{row[chosen_metric] / projected_health_spending_baseline :.2%} ({row['lower'] / projected_health_spending_baseline :.2%}- {row['upper'] / projected_health_spending_baseline:.2%})"
            for _, row in incremental_scenario_cost_summarized.iterrows()
        ],
        xticklabels_horizontal_and_wrapped=False,
        put_labels_in_legend=True,
        offset=50,
    )
    ax.set_title(name_of_plot)
    ax.set_ylabel('Cost \n(USD Millions)')
    ax.set_ylim(bottom=0)
    fig.tight_layout()
    fig.savefig(figurespath / name_of_plot.replace(' ', '_').replace(',', ''))
    plt.close(fig)

    # 6. Plot costs
    # ----------------------------------------------------
    # First summarize all input costs

    input_costs_subset_for_figure = input_costs[input_costs['draw'].isin(list(all_manuscript_scenarios.keys()))]
    agg_funcs = {
        chosen_metric: ('cost', chosen_metric),
        'lower': ('cost', lambda x: x.quantile(0.025)),
        'upper': ('cost', lambda x: x.quantile(0.975))
    }

    input_costs_for_plot_summarized = (
        input_costs_subset_for_figure
        .groupby(['draw', 'year', 'cost_subcategory', 'Facility_Level', 'cost_subgroup', 'cost_category'])
        .agg(**agg_funcs)
        .reset_index()
        .melt(
            id_vars=['draw', 'year', 'cost_subcategory', 'Facility_Level', 'cost_subgroup', 'cost_category'],
            value_vars=[chosen_metric, 'lower', 'upper'],
            var_name='stat',
            value_name='cost'
        )
    )

    do_stacked_bar_plot_of_cost_by_category(_df=input_costs_for_plot_summarized, _cost_category='all',
                                            _disaggregate_by_subgroup=False, _outputfilepath=figurespath,
                                            _scenario_dict=all_manuscript_scenarios_substitutedict)
    do_stacked_bar_plot_of_cost_by_category(_df=input_costs_for_plot_summarized, _cost_category='all', _year=[2025],
                                            _disaggregate_by_subgroup=False, _outputfilepath=figurespath,
                                            _scenario_dict=all_manuscript_scenarios_substitutedict)
    do_stacked_bar_plot_of_cost_by_category(_df=input_costs_for_plot_summarized,
                                            _cost_category='human resources for health',
                                            _disaggregate_by_subgroup=False, _outputfilepath=figurespath,
                                            _scenario_dict=all_manuscript_scenarios_substitutedict)
    do_stacked_bar_plot_of_cost_by_category(_df=input_costs_for_plot_summarized, _cost_category='medical consumables',
                                            _disaggregate_by_subgroup=False, _outputfilepath=figurespath,
                                            _scenario_dict=all_manuscript_scenarios_substitutedict)
    do_stacked_bar_plot_of_cost_by_category(_df=input_costs_for_plot_summarized, _cost_category='medical equipment',
                                            _disaggregate_by_subgroup=False, _outputfilepath=figurespath,
                                            _scenario_dict=all_manuscript_scenarios_substitutedict)
    do_stacked_bar_plot_of_cost_by_category(_df=input_costs_for_plot_summarized, _cost_category='malaria scale-up',
                                            _disaggregate_by_subgroup=False, _outputfilepath=figurespath,
                                            _scenario_dict=all_manuscript_scenarios_substitutedict)


# %%
# The following figures and results are generated only for the main (0.03 discount for both health and cost) scenario
# ----------------------------------------------------------
# Extract summary of incremental costs for appendix

def calculate_detailed_incremental_costs(_df, comparison_draw=0):
    """
    Calculate incremental costs relative to a specified comparison draw.

    Parameters:
    - _df (pd.DataFrame): The input DataFrame with cost data.
    - comparison_draw (int): The draw to use as the baseline for comparison.

    Returns:
    - pd.DataFrame: DataFrame with an additional column 'incremental_cost'.
    """
    # Identify all grouping columns (everything except 'draw' and 'cost')
    group_cols = [col for col in _df.columns if col not in ['draw', 'cost']]

    # Extract baseline costs for the specified comparison draw
    baseline_costs = _df[_df['draw'] == comparison_draw][group_cols + ['cost']]
    baseline_costs = baseline_costs.rename(columns={'cost': 'baseline_cost'})

    # Merge baseline costs with the original dataframe
    merged_df = _df.merge(baseline_costs, on=group_cols, how='left')

    # Calculate incremental costs
    merged_df['incremental_cost'] = merged_df['cost'] - merged_df['baseline_cost']
    merged_df.drop(columns=['baseline_cost', 'cost'], inplace=True)  # Drop the baseline cost column
    return merged_df[merged_df['draw'] != comparison_draw]


incremental_costs_df = calculate_detailed_incremental_costs(input_costs_subset_for_figure, comparison_draw=0)


def summarise_detailed_costs_df(_df, _metric, column_to_summarise='cost'):
    # Summarize values
    agg_func = np.mean if _metric == 'mean' else np.median
    groupby_cols = [col for col in _df.columns if col not in ['run', column_to_summarise]]
    _df = pd.concat(
        {
            chosen_metric: _df.groupby(by=groupby_cols, sort=False)[column_to_summarise].agg(agg_func),
            'lower': _df.groupby(by=groupby_cols, sort=False)[column_to_summarise].quantile(0.025),
            'upper': _df.groupby(by=groupby_cols, sort=False)[column_to_summarise].quantile(0.975),
        },
        axis=1
    )

    summarised_df = pd.melt(
        _df.reset_index(),
        id_vars=groupby_cols,  # Columns to keep
        value_vars=[_metric, 'lower', 'upper'],  # Columns to unpivot
        var_name='stat',  # New column name for the 'sub-category' of cost
        value_name=column_to_summarise
    )
    return summarised_df


incremental_costs_summary = summarise_detailed_costs_df(_df=incremental_costs_df, _metric=chosen_metric,
                                                        column_to_summarise='incremental_cost')
incremental_costs_summary = \
incremental_costs_summary[incremental_costs_summary.stat == 'median'].groupby(['draw', 'cost_category'])[
    'incremental_cost'].sum().reset_index()
incremental_costs_summary['scenario'] = incremental_costs_summary['draw'].map(all_manuscript_scenarios)
incremental_costs_summary = incremental_costs_summary.pivot(index='scenario', columns='cost_category',
                                                            values='incremental_cost')
incremental_costs_summary = incremental_costs_summary.reindex(all_manuscript_scenarios.values())
incremental_costs_summary = incremental_costs_summary[
    ['human resources for health', 'medical consumables', 'malaria scale-up',
     'medical equipment', 'facility operating cost']]
incremental_costs_summary.to_csv(figurespath / 'incremental_costs.csv')


# Plost costs over time
# First remove discounting
def remove_discounting(_df, _discount_rate=0, _year=None):
    if _year is None:
        # Initial year and discount rate
        initial_year = min(_df['year'].unique())
    else:
        initial_year = _year

    # Calculate the discounted values
    _df.loc[:, 'cost'] = _df['cost'] * ((1 + _discount_rate) ** (_df['year'] - initial_year))
    return _df


input_costs_for_plot_summarized_undiscounted = remove_discounting(input_costs_for_plot_summarized,
                                                                  _discount_rate=discount_rate_cost)

# Baseline
do_line_plot_of_cost(_df=input_costs_for_plot_summarized, _cost_category='all',
                     _year=list_of_relevant_years_for_costing, _draws=[baseline],
                     disaggregate_by='cost_category',
                     _outputfilepath=figurespath)

# HSS alone
do_line_plot_of_cost(_df=input_costs_for_plot_summarized, _cost_category='all',
                     _year=list_of_relevant_years_for_costing, _draws=[horizontal_hss],
                     disaggregate_by='cost_category',
                     _outputfilepath=figurespath)

# HTM without HSS
do_line_plot_of_cost(_df=input_costs_for_plot_summarized, _cost_category='all',
                     _year=list_of_relevant_years_for_costing, _draws=[vertical_htm],
                     disaggregate_by='cost_category',
                     _outputfilepath=figurespath)

# HTM with HSS
do_line_plot_of_cost(_df=input_costs_for_plot_summarized, _cost_category='all',
                     _year=list_of_relevant_years_for_costing, _draws=[diagonal_htm],
                     disaggregate_by='cost_category',
                     _outputfilepath=figurespath)

# Extracts for manuscript
# --------------------------
# ICER results
icer_result = convert_results_to_dict(icers_summarized)
hr_scenario_with_lowest_icer = min([1, 2, 3], key=lambda k: icer_result[k][chosen_metric])
hr_scenario_with_highest_icer = max([1, 2, 3], key=lambda k: icer_result[k][chosen_metric])
cons_scenario_with_lowest_icer = min([4, 5, 6], key=lambda k: icer_result[k][chosen_metric])
cons_scenario_with_highest_icer = max([4, 5, 6], key=lambda k: icer_result[k][chosen_metric])

# Get DALYs averted with vertical strategy as comparator
num_dalys_averted_v_vertical = (-1.0 *
                                pd.DataFrame(
                                    find_difference_relative_to_comparison(
                                        num_dalys.loc[0],
                                        comparison=vertical_htm)  # sets the comparator to 0 which is the Actual scenario
                                ).T.iloc[0].unstack(level='run'))
num_dalys_averted_v_vertical = num_dalys_averted_v_vertical[
    num_dalys_averted_v_vertical.index.get_level_values('draw').isin(
        list(all_manuscript_scenarios.keys()))]  # keep only relevant draws
# Summarize and convert to dictionary
num_dalys_averted_v_vertical_summarised = summarize_cost_data(num_dalys_averted_v_vertical, _metric=chosen_metric)
dalys_averted_v_vertical_result = convert_results_to_dict(num_dalys_averted_v_vertical_summarised)

print(f"The ICER of vertical strategy relative to the baseline scenario was "
      f"${icer_result[vertical_htm][chosen_metric]:.2f} [${icer_result[vertical_htm]['lower']:.2f} - ${icer_result[vertical_htm]['upper']:.2f}] "
      f"per DALY averted, assuming no additional implementation costs. The ICER of the diagonal HTM with HSS strategy "
      f"relative to the baseline scenario was "
      f"${icer_result[diagonal_htm][chosen_metric]:.2f} [${icer_result[diagonal_htm]['lower']:.2f} - ${icer_result[diagonal_htm]['upper']:.2f}], "
      f"demonstrating that the diagonal strategy was more cost-effective than the vertical one. While the horizontal "
      f"strategy, HSS expansion, averted "
      f"{dalys_averted_v_vertical_result[horizontal_hss][chosen_metric] / 1e6:.2f} [{dalys_averted_v_vertical_result[horizontal_hss]['lower'] / 1e6:.2f} - {dalys_averted_v_vertical_result[horizontal_hss]['upper'] / 1e6:.2f}] "
      f"million more DALYs than HTM expansion, it did so at a higher cost per DALY averted "
      f"(${icer_result[horizontal_hss][chosen_metric]:.2f} [${icer_result[horizontal_hss]['lower']:.2f} - ${icer_result[horizontal_hss]['upper']:.2f}] versus "
      f"${icer_result[vertical_htm][chosen_metric]:.2f} [${icer_result[vertical_htm]['lower']:.2f} - ${icer_result[vertical_htm]['upper']:.2f}]), meaning it was less cost-effective.")
