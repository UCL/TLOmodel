"""
Read in the output files generated by analysis_scenarios
generate life tables to estimate life expectancy for each run/draw
produce summary statistics
"""

import datetime
from pathlib import Path
import os

import matplotlib.lines as mlines
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from pandas import DataFrame

from tlo import Date

from tlo.analysis.utils import (
    compare_number_of_deaths,
    extract_params,
    extract_results,
    get_scenario_info,
    get_scenario_outputs,
    load_pickled_dataframes,
    summarize,
    make_age_grp_lookup,
    make_age_grp_types,
)

# outputspath = Path("./outputs/t.mangal@imperial.ac.uk")  # use for azure batch runs

outputspath = Path("./outputs")  # use for local runs

# Find results_folder associated with a given batch_file (and get most recent [-1])
results_folder = get_scenario_outputs("effect_of_treatment_packages.py", outputspath)[-1]

# look at one log (so can decide what to extract)
log = load_pickled_dataframes(results_folder)

# get basic information about the results
scenario_info = get_scenario_info(results_folder)

# Extract the parameters that have varied over the set of simulations
params = extract_params(results_folder)

# get number of draws and numbers of runs
info = get_scenario_info(results_folder)

# %% --------------------------------------------------------------
# define the target period over which we want to estimate life expectancy
# this should be a one-year period
TARGET_PERIOD = (Date(2019, 1, 1), Date(2020, 1, 1))


# %% --------------------------------------------------------------
# HELPER FUNCTIONS


def map_age_to_age_group(dataframe):
    """
    Maps ages to age-groups in 5-year intervals and adds a new column 'age-group' to the DataFrame.

    Args:
    - dataframe (pd.DataFrame): The DataFrame containing the age data.
    - age_column (str): The name of the column containing ages.

    Returns:
    - pd.DataFrame: The DataFrame with the 'age-group' column added.
    """
    # Define age groups in 5-year intervals
    age_groups = ['0'] + ['1-4'] + [f'{start}-{start + 4}' for start in range(5, 90, 5)] + ['90+']

    # Create a new column 'age-group' based on the age-to-age-group mapping
    dataframe['age_group'] = pd.cut(dataframe['age'], bins=[0] + [1] + list(range(5, 95, 5)) + [float('inf')],
                                    labels=age_groups, right=False)

    return dataframe


def get_multiplier(_draw, _run):
    """Helper function to get the multiplier from the simulation."""
    return load_pickled_dataframes(results_folder, _draw, _run, 'tlo.methods.population'
                                   )['tlo.methods.population']['scaling_factor']['scaling_factor'].values[0]


def extract_person_years(_draw, _run):
    """Helper function to get the multiplier from the simulation
    Note that if the scaling factor cannot be found a `KeyError` is thrown."""

    return load_pickled_dataframes(results_folder, _draw, _run,
                                   'tlo.methods.demography')['tlo.methods.demography']['person_years']


def create_multi_index_columns():
    return pd.MultiIndex.from_product([range(info['number_of_draws']),
                                       range(info['runs_per_draw'])],
                                      names=['draw', 'run'])


# %% extract key population data for life expectancy calculations
def num_deaths_by_age_group(results_folder):
    """ produces dataframe with mean (+ 95% UI) number of deaths
    for each draw by age-group
    dataframe returned: rows=age-gp, columns=draw median, draw lower, draw upper
    """

    def extract_deaths_by_age_group(df: pd.DataFrame) -> pd.Series:
        # Call the function to add the 'age-group' column
        df = map_age_to_age_group(df)
        return df.loc[pd.to_datetime(df.date).between(*TARGET_PERIOD)].groupby(["age_group", "sex"])[
            "person_id"].count()

    return extract_results(
        results_folder,
        module="tlo.methods.demography",
        key="death",
        custom_generate_series=extract_deaths_by_age_group,
        do_scaling=True
    )


# get population size in target period
# get one row of log for each draw/run and compile into df
def extract_pop_during_target_period(results_folder, key):
    module = "tlo.methods.demography"
    key = key

    # Create an empty DataFrame with the specified multi-index columns
    multi_index_columns = create_multi_index_columns()
    res = pd.DataFrame(columns=multi_index_columns)

    for draw in range(info['number_of_draws']):
        for run in range(info['runs_per_draw']):
            df: pd.DataFrame = load_pickled_dataframes(results_folder, draw, run, module)[module][key]
            output_from_eval: pd.Series = df.loc[pd.to_datetime(df.date).between(*TARGET_PERIOD)].stack()
            res.loc[:, (draw, run)] = output_from_eval[1:]
            # scale to full population size
            res.loc[:, (draw, run)] = res.loc[:, (draw, run)] * get_multiplier(_draw=draw, _run=run)

    return res


def get_population_size_by_age(results_folder):
    def extract_infants_during_target_period(df: pd.DataFrame) -> pd.Series:
        return df.loc[pd.to_datetime(df.date).between(*TARGET_PERIOD), '0']

    # get children aged=0 in target period
    num_children = extract_results(
        results_folder,
        module="tlo.methods.demography",
        key="num_children",
        custom_generate_series=extract_infants_during_target_period,
        do_scaling=True
    )
    num_f0 = num_children / 2  # todo should this be exactly 50/50?
    num_m0 = num_children / 2

    # get age_range_m and age_range_f for all age-groups
    num_males = extract_pop_during_target_period(results_folder=results_folder, key='age_range_m')
    num_females = extract_pop_during_target_period(results_folder=results_folder, key='age_range_f')
    num_males = num_males.reset_index(level=0, drop=True)
    num_females = num_females.reset_index(level=0, drop=True)

    # then subtract age 0 from age-group 0-4
    num_males_adj = num_males.iloc[0:1, :] - num_m0.iloc[0:1, :].values
    # add adjusted data back into dataframe
    num_males.iloc[0] = num_males_adj.values
    # change first row index
    num_males.index.values[0] = '1-4'
    # add in infant numbers to main dataframe
    t1 = pd.concat([num_m0, num_males])
    # set correct index
    t1.index.values[0] = '0'

    # repeat for females
    num_females_adj = num_females.iloc[0:1, :] - num_f0.iloc[0:1, :].values
    num_females.iloc[0] = num_females_adj.values
    num_females.index.values[0] = '1-4'
    t2 = pd.concat([num_f0, num_females])
    t2.index.values[0] = '0'

    # combine pop aged 90+
    # Sum the last three rows column-wise
    last_three_rows_sum = t1.iloc[-3:].sum()
    t1.loc['90+'] = last_three_rows_sum

    last_three_rows_sum = t2.iloc[-3:].sum()
    t2.loc['90+'] = last_three_rows_sum

    # remove unneeded columns
    indices_to_remove = ['90-94', '95-99', '100+']
    t1 = t1.drop(indices_to_remove, axis=0)
    t2 = t2.drop(indices_to_remove, axis=0)

    # output is 0, 1-4, 5-9, 10-14 and index by male/female
    # join male and female dataframe and add index for sex
    t3 = pd.concat([t1, t2], ignore_index=True)

    # Create a MultiIndex for rows using age group and 'Male' and 'Female'
    multi_index_rows_male = pd.MultiIndex.from_product([t1.index, ['M']], names=['age_group', 'sex'])
    multi_index_rows_female = pd.MultiIndex.from_product([t1.index, ['F']], names=['age_group', 'sex'])
    t3.index = multi_index_rows_male.append(multi_index_rows_female)

    return t3


def aggregate_person_years_by_age(results_folder):
    """ extract person-years for each draw/run
    calculate for men and women separately
    return a dataframe with index=age-groups and columns=person-years
    """

    # Create an empty DataFrame to store all outputs
    output = pd.DataFrame()

    for draw in range(info['number_of_draws']):
        for run in range(info['runs_per_draw']):

            _df = extract_person_years(_draw=draw, _run=run)

            # create empty dataframe to store outputs from each run
            tmp = pd.DataFrame(columns=['M', 'F'])

            for sex in ['M', 'F']:
                py = _df[sex]  # extract values for each sex
                # create dataframe one row per year and one column per age_year
                new_df = pd.DataFrame(py.tolist())
                new_df.index = _df.date
                new_df = new_df.loc[TARGET_PERIOD[0]:TARGET_PERIOD[1]]

                # sum values for each age (single years)
                py_by_single_age_years = new_df.sum(numeric_only=True, axis=0).reset_index()
                # py_by_single_age_years = py_by_single_age_years.reset_index()
                py_by_single_age_years = py_by_single_age_years.rename(columns={'index': 'age', 0: 'person_years'})

                # convert single age years to float for mapping
                py_by_single_age_years['age'] = py_by_single_age_years['age'].astype(float)
                # map single age bands to age-groups
                py_with_age_groups = map_age_to_age_group(py_by_single_age_years)

                summary = py_with_age_groups.groupby(["age_group"])["person_years"].sum() * get_multiplier(_draw=draw,
                                                                                                           _run=run)
                tmp[sex] = summary

            # then join each draw/run in a new column
            output = pd.concat([output, pd.concat([tmp['M'], tmp['F']], ignore_index=True)], axis=1)

    # Create a MultiIndex for rows using age group and 'Male' and 'Female'
    multi_index_rows_male = pd.MultiIndex.from_product([summary.index, ['M']], names=['age_group', 'sex'])
    multi_index_rows_female = pd.MultiIndex.from_product([summary.index, ['F']], names=['age_group', 'sex'])
    output.index = multi_index_rows_male.append(multi_index_rows_female)

    # multi-index columns
    multi_index_columns = create_multi_index_columns()
    output.columns = multi_index_columns

    return output


# %% GENERATE LIFE EXPECTANCY ESTIMATES

def estimate_life_expectancy(person_years_at_risk, number_of_deaths_in_interval):
    """
    for a single run, estimate life expectancy for males and females
    return: pd.Series
    """

    estimated_life_expectancy = pd.Series(dtype=float)

    # first age-group is 0, then 1-4, 5-9, 10-14 etc. 22 categories in total
    level_0_values = person_years_at_risk.index.get_level_values('age_group').unique()
    interval_width = pd.Series([1] + [4] + [5] * 18, index=level_0_values)

    fraction_of_last_age_survived = 0.5
    number_age_groups = 20

    # separate male and female data
    for sex in ['M', 'F']:
        person_years_by_sex = person_years_at_risk.xs(key=sex, level='sex')
        number_of_deaths_by_sex = number_of_deaths_in_interval.xs(key=sex, level='sex')

        death_rate_in_interval = number_of_deaths_by_sex / person_years_by_sex
        # if no deaths or person-years, convert nan to 0
        death_rate_in_interval = death_rate_in_interval.fillna(0)
        # if no deaths in age 90+, set death rate equal to value in age 85-89
        if death_rate_in_interval[number_age_groups - 1] == 0:
            death_rate_in_interval[number_age_groups - 1] = death_rate_in_interval[number_age_groups - 2]

        # Calculate the probability of dying in the interval
        condition = number_of_deaths_by_sex > (
            person_years_by_sex / interval_width / fraction_of_last_age_survived)
        probability_of_dying_in_interval = pd.Series(index=number_of_deaths_by_sex.index, dtype=float)
        probability_of_dying_in_interval[condition] = 1
        probability_of_dying_in_interval[~condition] = interval_width * death_rate_in_interval / (
            1 + interval_width * (1 - fraction_of_last_age_survived) * death_rate_in_interval)
        # all those surviving to final interval die during this interval
        probability_of_dying_in_interval[number_age_groups - 1] = 1

        # number_alive_at_start_of_interval
        # keep dtype as float in case using aggregated outputs
        # note range stops BEFORE the specified number
        number_alive_at_start_of_interval = pd.Series(index=range(number_age_groups), dtype=float)
        number_alive_at_start_of_interval[0] = 100_000  # hypothetical cohort
        for i in range(1, number_age_groups):
            number_alive_at_start_of_interval[i] = (1 - probability_of_dying_in_interval[i - 1]) * \
                                                   number_alive_at_start_of_interval[i - 1]

        # number_dying_in_interval
        number_dying_in_interval = pd.Series(index=range(number_age_groups), dtype=float)
        for i in range(0, number_age_groups - 1):
            number_dying_in_interval[i] = number_alive_at_start_of_interval[i] - number_alive_at_start_of_interval[
                i + 1]

        number_dying_in_interval[number_age_groups - 1] = number_alive_at_start_of_interval[number_age_groups - 1]

        # person-years lived in interval
        py_lived_in_interval = pd.Series(index=range(number_age_groups), dtype=float)
        for i in range(0, number_age_groups - 1):
            py_lived_in_interval[i] = interval_width[i] * (
                number_alive_at_start_of_interval[i + 1] + fraction_of_last_age_survived * number_dying_in_interval[i])
        py_lived_in_interval[number_age_groups - 1] = number_alive_at_start_of_interval[number_age_groups - 1] / \
                                                      death_rate_in_interval[number_age_groups - 1]

        # person-years lived beyond start of interval
        # have to iterate backwards for this
        py_lived_beyond_start_of_interval = pd.Series(index=range(number_age_groups), dtype=float)
        py_lived_beyond_start_of_interval[number_age_groups - 1] = py_lived_in_interval[number_age_groups - 1]
        for i in range((number_age_groups - 2), -1, -1):
            py_lived_beyond_start_of_interval[i] = py_lived_beyond_start_of_interval[i + 1] + py_lived_in_interval[i]

        # calculate observed life expectancy at start of interval
        condition = number_alive_at_start_of_interval == 0
        observed_life_expectancy = pd.Series(index=range(number_age_groups), dtype=float)
        observed_life_expectancy[condition] = 0
        observed_life_expectancy[~condition] = py_lived_beyond_start_of_interval / number_alive_at_start_of_interval

        # estimated life expectancy from birth
        # estimated_life_expectancy = pd.concat(estimated_life_expectancy, observed_life_expectancy[0])
        estimated_life_expectancy = estimated_life_expectancy.append(pd.Series([observed_life_expectancy[0]]))

    return estimated_life_expectancy


# generate life expectancy estimates for all draws/runs
def produce_life_expectancy_estimates(results_folder, median=True):
    """
    produces sets of life expectancy estimates for each draw/run
    calls:
    *1 num_deaths_by_age_group
    *2 aggregate_person_years_by_age

    Args:
    - results_folder (PosixPath): The path to the folder containing all logged outputs
    - median: declare whether to return a median value with 95% uncertainty intervals
    or return the estimate for each draw/run

    Returns:
    - pd.DataFrame: The DataFrame with the life expectancy estimates (in years)
    for every draw/run in the results folder
    """
    output = pd.DataFrame()

    # extract numbers of deaths
    deaths = num_deaths_by_age_group(results_folder)

    # extract person-years
    person_years = get_population_size_by_age(results_folder)

    for draw in range(info['number_of_draws']):
        for run in range(info['runs_per_draw']):
            # select column
            le = estimate_life_expectancy(
                number_of_deaths_in_interval=deaths.loc[:, (draw, run)],
                person_years_at_risk=person_years.loc[:, (draw, run)])

            output = pd.concat([output, le], axis=1)

    multi_index_columns = create_multi_index_columns()
    output.columns = multi_index_columns
    output.index = ['M', 'F']

    if not median:
        return output

    else:
        summary = pd.DataFrame(
            columns=pd.MultiIndex.from_product(
                [
                    output.columns.unique(level='draw'),
                    ["median", "lower", "upper"]
                ],
                names=['draw', 'stat']),
            index=output.index
        )

        summary.loc[:, (slice(None), "median")] = output.groupby(axis=1, by='draw').median().values
        summary.loc[:, (slice(None), "lower")] = output.groupby(axis=1, by='draw').quantile(0.025).values
        summary.loc[:, (slice(None), "upper")] = output.groupby(axis=1, by='draw').quantile(0.975).values

        return summary


test = produce_life_expectancy_estimates(results_folder, median=False)
