"""
Read in the output files generated by analysis_scenarios
generate life tables to estimate life expectancy for each run/draw
produce summary statistics
"""

import datetime
from pathlib import Path
import os

import matplotlib.lines as mlines
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from tlo import Date

from tlo.analysis.utils import (
    compare_number_of_deaths,
    extract_params,
    extract_results,
    get_scenario_info,
    get_scenario_outputs,
    load_pickled_dataframes,
    summarize,
    make_age_grp_lookup,
    make_age_grp_types,
)

# outputspath = Path("./outputs/t.mangal@imperial.ac.uk")  # use for azure batch runs

outputspath = Path("./outputs")  # use for local runs

# Find results_folder associated with a given batch_file (and get most recent [-1])
results_folder = get_scenario_outputs("effect_of_treatment_packages.py", outputspath)[-1]

# Declare path for output graphs from this script
make_graph_file_name = lambda stub: results_folder / f"{stub}.png"  # noqa: E731

# look at one log (so can decide what to extract)
log = load_pickled_dataframes(results_folder)

# get basic information about the results
scenario_info = get_scenario_info(results_folder)

# Extract the parameters that have varied over the set of simulations
params = extract_params(results_folder)

# %% --------------------------------------------------------------
from tlo.util import create_age_range_lookup


def map_age_to_age_group(dataframe):
    """
    Maps ages to age-groups in 5-year intervals and adds a new column 'age-group' to the DataFrame.

    Args:
    - dataframe (pd.DataFrame): The DataFrame containing the age data.
    - age_column (str): The name of the column containing ages.

    Returns:
    - pd.DataFrame: The DataFrame with the 'age-group' column added.
    """
    # Define age groups in 5-year intervals
    age_groups = ['0'] + ['1-4'] + [f'{start}-{start + 4}' for start in range(5, 100, 5)] + ['100+']

    # Create a new column 'age-group' based on the age-to-age-group mapping
    dataframe['age_group'] = pd.cut(dataframe['age'], bins=[0] + [1] + list(range(5, 105, 5)) + [float('inf')],
                             labels=age_groups, right=False)

    return dataframe


TARGET_PERIOD = (Date(2019, 1, 1), Date(2020, 1, 1))


def num_deaths_by_age_group(results_folder):
    """ produces dataframe with mean (+ 95% UI) number of deaths
    for each draw by age-group
    dataframe returned: rows=age-gp, columns=draw median, draw lower, draw upper
    """

    def extract_deaths_by_age_group(df: pd.DataFrame) -> pd.Series:

        # Call the function to add the 'age-group' column
        df = map_age_to_age_group(df)
        return df.loc[pd.to_datetime(df.date).between(*TARGET_PERIOD)].groupby(["age_group", "sex"])["person_id"].count()

    return extract_results(
        results_folder,
        module="tlo.methods.demography",
        key="death",
        custom_generate_series=extract_deaths_by_age_group,
        do_scaling=True
    )

deaths_summarized_by_age = num_deaths_by_age_group(results_folder)

# todo extract total population-years at risk over the specified time period.
#  Sum of the populations for each year or average population x years


TARGET_PERIOD = (Date(2017, 1, 1), Date(2020, 1, 1))
years = range(2010, 2020, 1)  # todo replace with simulation end date
# remember range finishes before the end point

# todo this will return the person-years for males in one run
# todo find a nice way to do this across draws/runs
# todo consider what the best output format would be
# this is what it needs to read in
# _df = log['tlo.methods.demography']['person_years']

def get_multiplier(_draw, _run):
    """Helper function to get the multiplier from the simulation."""
    return load_pickled_dataframes(results_folder, _draw, _run, 'tlo.methods.population'
                                   )['tlo.methods.population']['scaling_factor']['scaling_factor'].values[0]


def get_person_years(_df):
    """ extract person-years for each draw/run
    calculate for men and women separately
    return a dataframe with index=age-groups and columns=person-years
    """
    output = pd.DataFrame()
    for sex in ['M', 'F']:

        py = _df[sex] # extract values for males
        # using series of py for M per year:
        # create dataframe one row per year and one column per age_year
        new_df = pd.DataFrame(py.tolist())
        new_df.index = _df.date
        new_df = new_df.loc[TARGET_PERIOD[0]:TARGET_PERIOD[1]]

        # sum values for each age (single years)
        py_by_single_age_years = new_df.sum(numeric_only=True, axis=0)
        py_by_single_age_years = py_by_single_age_years.reset_index()
        py_by_single_age_years = py_by_single_age_years.rename(columns={'index': 'age', 0: 'person_years'})

        # convert single age years to float for mapping
        py_by_single_age_years['age'] = py_by_single_age_years['age'].astype(float)
        # map single age bands to age-groups
        py_with_age_groups = map_age_to_age_group(py_by_single_age_years)

        summary = py_with_age_groups.groupby(["age_group"])["person_years"].sum()

        output = pd.concat([output, summary], axis=1)
        output.columns = ['Male_py', 'Female_py']

    return output






# do we want the population size at start date
# or the person-years lived within the interval for each age-group
# get person-years by age-group for target period
# use demography.age_range_m for pop size
# select target years
# for each column, take median
# todo adapt function to return all draws/runs
# todo return within target period

def extract_pop_size(results_folder, draw, key):
    module = "tlo.methods.demography"

    def get_multiplier(_draw, _run):
        """Helper function to get the multiplier from the simulation."""
        return load_pickled_dataframes(results_folder, _draw, _run, 'tlo.methods.population'
                                           )['tlo.methods.population']['scaling_factor']['scaling_factor'].values[0]

    # get number of draws and numbers of runs
    info = get_scenario_info(results_folder)

    # Dictionary to store DataFrames
    dataframes = {}

    # get the dataframes from each run
    for run in range(info['runs_per_draw']):

        df_name = f'df_{run}'  # Create a dynamic name for each DataFrame
        data = load_pickled_dataframes(results_folder, draw, run, module)[module][key]
        dataframes[df_name] = pd.DataFrame(data)

    # Concatenate DataFrames along a new axis (axis=2)
    concatenated_df = pd.concat([dataframes["df_1"],
                                 dataframes["df_2"],
                                 dataframes["df_3"],
                                 dataframes["df_4"],
                                 ], axis=1, keys=['df1', 'df2', 'df3', 'df4'])

    # Remove column 'B' from all data frames within concatenated_df
    concatenated_df = concatenated_df.drop('date', level=1, axis=1)
    # Calculate the mean for each row in each column
    tmp = concatenated_df.groupby(level=1, axis=1).mean() * get_multiplier(0, 0)

    return tmp


pop_baseline_m = extract_pop_size(results_folder=results_folder, draw=0, key="age_range_m")






def generate_life_expectancy_estimate(population_years_at_risk, number_of_deaths_in_interval):
    # Initialize variables

    life_table = pd.DataFrame()
    fraction_survived = 1
    number_age_groups = 20
    # first age-group is 0, then 1-4, 5-9, 10-14 etc.
    interval_width = pd.Series([1] + [4] + [5] * (number_age_groups - 2))
    fraction_of_last_age_survived = 0.5

    death_rate_in_interval = number_of_deaths_in_interval / population_years_at_risk

    # Calculate the probability of dying in the interval
    condition = number_of_deaths_in_interval > (
        population_years_at_risk / interval_width / fraction_of_last_age_survived)
    probability_of_dying_in_interval = pd.Series(index=number_of_deaths_in_interval.index, dtype=float)
    probability_of_dying_in_interval[condition] = 1
    probability_of_dying_in_interval[~condition] = interval_width * death_rate_in_interval / (
        1 + interval_width * (1 - fraction_of_last_age_survived) * death_rate_in_interval)

    # number_alive_at_start_of_interval
    # keep dtype as float in case using aggregated outputs
    # note range stops BEFORE the specified number
    number_alive_at_start_of_interval = pd.Series(index=range(number_age_groups), dtype=float)
    number_alive_at_start_of_interval[0] = 100_000  # hypothetical cohort
    for i in range(1, number_age_groups):
        number_alive_at_start_of_interval[i] = (1 - probability_of_dying_in_interval[i - 1]) * \
                                               number_alive_at_start_of_interval[i - 1]

    # number_dying_in_interval
    number_dying_in_interval = pd.Series(index=range(number_age_groups), dtype=float)
    for i in range(0, number_age_groups - 1):
        number_dying_in_interval[i] = number_alive_at_start_of_interval[i] - number_alive_at_start_of_interval[i + 1]

    number_dying_in_interval[number_age_groups - 1] = number_alive_at_start_of_interval[number_age_groups - 1]

    # person-years lived in interval
    py_lived_in_interval = pd.Series(index=range(number_age_groups), dtype=float)
    for i in range(0, number_age_groups - 1):
        py_lived_in_interval[i] = interval_width[i] * (
            number_alive_at_start_of_interval[i + 1] + fraction_of_last_age_survived * number_dying_in_interval[i])
    py_lived_in_interval[number_age_groups - 1] = number_alive_at_start_of_interval[number_age_groups - 1] / \
                                                  death_rate_in_interval[number_age_groups - 1]

    # person-years lived beyond start of interval
    # have to iterate backwards for this
    py_lived_beyond_start_of_interval = pd.Series(index=range(number_age_groups), dtype=float)
    py_lived_beyond_start_of_interval[number_age_groups - 1] = py_lived_in_interval[number_age_groups - 1]
    for i in range((number_age_groups - 2), -1, -1):
        py_lived_beyond_start_of_interval[i] = py_lived_beyond_start_of_interval[i + 1] + py_lived_in_interval[i]

    # calculate observed life expectancy at start of interval
    condition = number_alive_at_start_of_interval == 0
    observed_life_expectancy = pd.Series(index=range(number_age_groups), dtype=float)
    observed_life_expectancy[condition] = 0
    observed_life_expectancy[~condition] = py_lived_beyond_start_of_interval / number_alive_at_start_of_interval

    return observed_life_expectancy[0]


# Example usage:
number_of_deaths_in_interval = pd.Series(data=[0,
                                               17243.97627,
                                               1105.010284,
                                               1279.485592,
                                               1541.198554,
                                               2297.258222,
                                               2297.258222,
                                               3111.476326,
                                               2820.684146,
                                               2500.812748,
                                               2413.575094,
                                               2326.33744,
                                               2268.179004,
                                               2907.9218,
                                               2733.446492,
                                               4565.437226,
                                               3140.555544,
                                               2937.001018,
                                               2529.891966,
                                               1599.35699])

population_years_at_risk = pd.Series(data=[1,
                                           1464865.607,
                                           1305656.888,
                                           1242046.099,
                                           1065171.755,
                                           901201.3148,
                                           762529.794,
                                           629928.5599,
                                           483260.2541,
                                           388098.5132,
                                           303877.8281,
                                           238485.9366,
                                           186724.9286,
                                           146813.7019,
                                           114644.817,
                                           96397.60767,
                                           64301.4208,
                                           37839.33242,
                                           18792.44463,
                                           8105.832018])

result = generate_life_expectancy_estimate(population_years_at_risk, number_of_deaths_in_interval)
print(f"Estimated life expectancy at birth: {result:.2f} years")
