"""
Read in the output files generated by analysis_scenarios and plot outcomes for comparison
"""

import datetime
from pathlib import Path
import matplotlib
import matplotlib.lines as mlines
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from tlo import Date

from tlo.analysis.utils import (
    compare_number_of_deaths,
    extract_params,
    extract_results,
    get_scenario_info,
    get_scenario_outputs,
    load_pickled_dataframes,
    summarize,
    make_age_grp_lookup,
    make_age_grp_types,
)

# outputspath = Path("./outputs/t.mangal@imperial.ac.uk")
outputspath = Path("./outputs")

# Find results_folder associated with a given batch_file (and get most recent [-1])
results_folder = get_scenario_outputs("exclude_HTM_services.py", outputspath)[-1]

# Declare path for output graphs from this script
make_graph_file_name = lambda stub: results_folder / f"{stub}.png"  # noqa: E731

# look at one log (so can decide what to extract)
log = load_pickled_dataframes(results_folder)

# get basic information about the results
scenario_info = get_scenario_info(results_folder)

# Extract the parameters that have varied over the set of simulations
params = extract_params(results_folder)

# Create a list of strings summarizing the parameter values in the different draws
param_strings = [f"{row.module_param}={row.value}" for _, row in params.iterrows()]

TARGET_PERIOD = (Date(2010, 1, 1), Date(2020, 1, 1))


# extract total deaths
def extract_total_deaths(results_folder, do_scaling=True):
    """ sum all deaths occurring for each run of each draw
    dataframe returned: row=total deaths, column=run/draw
    """
    def extract_deaths_total(df: pd.DataFrame) -> pd.Series:
        return pd.Series({"Total": len(df)})

    return extract_results(
        results_folder,
        module="tlo.methods.demography",
        key="death",
        custom_generate_series=extract_deaths_total,
        do_scaling=do_scaling
    )


def summarise_total_deaths(results_folder, do_scaling=True):
    """ sum all deaths occurring for each run of each draw
    dataframe returned: row=total deaths, column=run/draw
    """
    def extract_deaths_total(df: pd.DataFrame) -> pd.Series:
        return pd.Series({"Total": len(df)})

    return summarize(extract_results(
        results_folder,
        module="tlo.methods.demography",
        key="death",
        custom_generate_series=extract_deaths_total,
        do_scaling=do_scaling
    ),
        only_mean=False)


def round_to_nearest_100(x):
    return 100 * round(x / 100)


total_deaths = summarise_total_deaths(results_folder)
rounded_total_deaths = total_deaths.applymap(round_to_nearest_100)


def plot_summarized_total_deaths(summarized_total_deaths, scenario_info, mean_deaths_difference_by_run):
    """ barplot with mean total deaths for each scenario
    with the mean difference in numbers of deaths compared with the baseline
    added above each bar
    """
    list_of_scenarios = list(range(scenario_info['number_of_draws']))
    fig, ax = plt.subplots()
    number_of_draws = scenario_info['number_of_draws']
    statistic_values = {
        s: np.array(
            [summarized_total_deaths[(d, s)].values[0] for d in range(number_of_draws)]
        )
        for s in ["mean", "lower", "upper"]
    }
    ax.bar(
        list_of_scenarios,
        statistic_values["mean"],
        yerr=[
            statistic_values["mean"] - statistic_values["lower"],
            statistic_values["upper"] - statistic_values["mean"]
        ],
        color="mediumaquamarine"
    )
    ax.set_ylim(0, max(statistic_values["upper"]) * 1.1)
    plt.title("Total deaths by scenario (scaled)")

    # add values above bars
    # create gap above bar for value
    gap = statistic_values["mean"][0] * 0.1
    for i in range(len(list_of_scenarios)):
        plt.text(list_of_scenarios[i], (statistic_values["mean"][i]) + gap,
                 mean_deaths_difference_by_run[i], ha="center")

    ax.set_ylabel("Total number of deaths")
    fig.tight_layout()

    return fig, ax


def compute_difference_in_deaths_across_runs(total_deaths, scenario_info):
    """# this computes the mean difference in deaths between each scenario and baseline
    # numbers of deaths are compared run-for-run
    """
    out = [None] * scenario_info["number_of_draws"]
    for scenario in range(scenario_info["number_of_draws"]):
        deaths_difference_by_run = [
            total_deaths[scenario][run_number]["Total"] - total_deaths[0][run_number]["Total"]
            for run_number in range(scenario_info["runs_per_draw"])
        ]

        out[scenario] = np.mean(deaths_difference_by_run)

    return out


def extract_deaths_by_age(results_folder):
    """ produces dataframe with mean (+ 95% UI) number of deaths
    for each draw by age-group
    dataframe returned: rows=age-gp, columns=draw median, draw lower, draw upper
    """
    def extract_deaths_by_age_group(df: pd.DataFrame) -> pd.Series:
        _, age_group_lookup = make_age_grp_lookup()
        df["Age_Grp"] = df["age"].map(age_group_lookup).astype(make_age_grp_types())
        df = df.rename(columns={"sex": "Sex"})
        return df.groupby(["Age_Grp"])["person_id"].count()

    return summarize(extract_results(
        results_folder,
        module="tlo.methods.demography",
        key="death",
        custom_generate_series=extract_deaths_by_age_group,
        do_scaling=True
    ), only_mean=False, collapse_columns=True
    )


# line plot of number deaths by age
def plot_summarized_deaths_by_age(deaths_summarized_by_age):
    fig, ax = plt.subplots()

    for i in range(scenario_info["number_of_draws"]):
        central_values = deaths_summarized_by_age[(i, "mean")].values
        lower_values = deaths_summarized_by_age[(i, "lower")].values
        upper_values = deaths_summarized_by_age[(i, "upper")].values
        ax.plot(
            deaths_summarized_by_age.index, central_values,
            color=f"C{i}",
            label=i
        )
        ax.fill_between(
            deaths_summarized_by_age.index, lower_values, upper_values,
            alpha=0.5,
            color=f"C{i}",
            label="_"
        )
    ax.set(xlabel="Age-Group", ylabel="Total deaths")
    ax.set_xticks(deaths_summarized_by_age.index)
    ax.set_xticklabels(labels=deaths_summarized_by_age.index, rotation=90)
    ax.legend()
    fig.tight_layout()
    return fig, ax


# line plot of number deaths by age
# todo for every run, aggregate numbers deaths, then summarise by age-groups
def barplot_summarized_deaths_by_age(deaths_summarized_by_age, proportion):

    # combine some age-groups
    deaths_summarized_by_age.loc['15-59'] = deaths_summarized_by_age.loc[['15-19', '20-24', '25-29',
                                                                          '30-34', '35-39', '40-44',
                                                                          '45-49', '50-54', '55-59']].sum()
    deaths_summarized_by_age.loc['60+'] = deaths_summarized_by_age.loc[['60-64', '65-69', '70-74',
                                                                        '75-79', '80-84', '85-89',
                                                                        '90-94', '95-99', '100+']].sum()

    # select only age-groups of interest
    deaths_to_plot = deaths_summarized_by_age.loc[['0-4', '5-9', '10-14', '15-59', '60+']]
    deaths_to_plot = deaths_to_plot.stack().reset_index()

    central_values = deaths_to_plot.loc[deaths_to_plot.stat == 'mean']
    central_values = central_values.drop('stat', axis=1)

    if proportion:
        # calculate deaths as a proportion of total
        # get column sums
        sum_deaths = central_values.sum(axis=0)
        d = pd.DataFrame()
        d['Age_Grp'] = central_values['Age_Grp']
        d['0'] = central_values[0] / sum_deaths[0]
        d['1'] = central_values[1] / sum_deaths[1]
        d['2'] = central_values[2] / sum_deaths[2]
        d['3'] = central_values[3] / sum_deaths[3]
        d['4'] = central_values[4] / sum_deaths[4]
        d['5'] = central_values[5] / sum_deaths[5]

        # replace central_values for plotting
        central_values = d

    # x-axis will be the draw
    # stacking variable will be values by age-group
    # switch age-group to columns
    tmp = central_values.T
    # Rename the columns using the first row
    tmp.columns = tmp.iloc[0]
    # Delete the first row
    tmp = tmp.drop(tmp.index[0])
    # Reset the index
    tmp = tmp.reset_index(drop=True)
    tmp.index = ["Status quo", "Excl HIV", "Excl TB",
                       "Excl malaria", "Excl HTM"]

    tmp.plot(kind='bar', stacked=True)

    # Customize the plot
    plt.xticks(range(scenario_info["number_of_draws"]), tmp.index, rotation=0)
    plt.ylabel("Total deaths")
    plt.xlabel("")
    plt.subplots_adjust(bottom=0.2, left=0.15)
    plt.savefig(outputspath / "Mar2024_HTMresults/Deaths_by_age_barplot_excl_htm.png")

    plt.show()


# total deaths in the scenario runs
total_deaths = extract_total_deaths(results_folder, do_scaling=True)
deaths_summarized_by_age = extract_deaths_by_age(results_folder)

# Compute and print the difference between the deaths across the scenario draws
mean_deaths_difference_by_run = compute_difference_in_deaths_across_runs(
    total_deaths, scenario_info
)
format_mean_deaths_difference_by_run = [round(elem) for elem in mean_deaths_difference_by_run]
print(f"Mean difference in total deaths = {format_mean_deaths_difference_by_run}")

# Plot the total deaths across the two scenario draws as a bar plot with error bars
fig_1, ax_1 = plot_summarized_total_deaths(summarize(total_deaths), scenario_info, format_mean_deaths_difference_by_run)
plt.show()

# Plot the total deaths across scenarios by age
fig_1, ax_1 = plot_summarized_deaths_by_age(deaths_summarized_by_age)
fig_1.savefig(outputspath / "Mar2024_HTMresults/Deaths_by_age_excl_htm.png")
plt.show()


# barplot deaths by broad age-group
barplot_summarized_deaths_by_age(deaths_summarized_by_age, proportion=False)


def get_num_deaths_by_cause_label(_df):
    """Return total number of Deaths by label within the TARGET_PERIOD
    values are summed for all ages and aggregated across the runs
    df returned: rows=COD, columns=draw
    """
    return _df \
        .loc[pd.to_datetime(_df.date).between(*TARGET_PERIOD)] \
        .groupby(_df['label']) \
        .size()


num_deaths_by_cause_label = summarize(
    extract_results(
        results_folder,
        module='tlo.methods.demography',
        key='death',
        custom_generate_series=get_num_deaths_by_cause_label,
        do_scaling=True
    )
)
TARGET_PERIOD = (Date(2010, 1, 1), Date(2020, 1, 1))

mean_deaths_by_cause = num_deaths_by_cause_label.xs('mean', level=1, axis=1)
mean_deaths_by_cause_lower = num_deaths_by_cause_label.xs('lower', level=1, axis=1)
mean_deaths_by_cause_upper = num_deaths_by_cause_label.xs('upper', level=1, axis=1)


deaths_by_cause_by_run = extract_results(
        results_folder,
        module='tlo.methods.demography',
        key='death',
        custom_generate_series=get_num_deaths_by_cause_label,
        do_scaling=True
    )

deaths_by_cause_by_run.to_csv(outputspath / "Mar2024_HTMresults/deaths_by_cause_by_run.csv")


# Function to round to the nearest 1000
def round_to_nearest_100(value):
    return round(value, -2)

# Apply the rounding function to the entire DataFrame
rounded_deaths = mean_deaths_by_cause.applymap(round_to_nearest_100)
rounded_deaths_lower = mean_deaths_by_cause_lower.applymap(round_to_nearest_100)
rounded_deaths_upper = mean_deaths_by_cause_upper.applymap(round_to_nearest_100)

# Apply the rounding function to the entire DataFrame
sum_deaths = mean_deaths_by_cause.sum(axis=0)

rounded_deaths.to_csv(outputspath / "Mar2024_HTMresults/deaths_by_cause_excl_htm.csv")


def summarise_deaths_for_one_cause(results_folder, label):
    """ returns mean deaths for each year of the simulation
    values are aggregated across the runs of each draw
    for the specified cause
    """

    results_deaths = extract_results(
        results_folder,
        module="tlo.methods.demography",
        key="death",
        custom_generate_series=(
            lambda df: df.assign(year=df["date"].dt.year).groupby(
                ["year", "label"])["person_id"].count()
        ),
        do_scaling=True,
    )
    # removes multi-index
    results_deaths = results_deaths.reset_index()

    # select only cause specified
    tmp = results_deaths.loc[
        (results_deaths.label == label)
    ]

    # group deaths by year
    tmp = pd.DataFrame(tmp.groupby(["year"]).sum())

    # get mean for each draw
    mean_deaths = pd.concat({'mean': tmp.iloc[:, 1:].groupby(level=0, axis=1).mean()}, axis=1).swaplevel(axis=1)

    return mean_deaths


aids_deaths = summarise_deaths_for_one_cause(results_folder, 'AIDS')
tb_deaths = summarise_deaths_for_one_cause(results_folder, 'TB (non-AIDS)')
malaria_deaths = summarise_deaths_for_one_cause(results_folder, 'Malaria')


# -----------------------------------------------------------------------------------
# plot life expectancy and numbers of deaths by cause

# all cause deaths
total_deaths = summarise_total_deaths(results_folder)
mean_total_deaths = total_deaths.loc[:, total_deaths.columns.get_level_values(1) == 'mean']
lower_total_deaths = total_deaths.loc[:, total_deaths.columns.get_level_values(1) == 'lower']
upper_total_deaths = total_deaths.loc[:, total_deaths.columns.get_level_values(1) == 'upper']

# deaths by cause
mean_deaths_by_cause = num_deaths_by_cause_label.xs('mean', level=1, axis=1)
mean_deaths_by_cause_lower = num_deaths_by_cause_label.xs('lower', level=1, axis=1)
mean_deaths_by_cause_upper = num_deaths_by_cause_label.xs('upper', level=1, axis=1)

deaths_for_plot = [mean_deaths_by_cause.loc['AIDS', 0],
               mean_deaths_by_cause.loc['TB (non-AIDS)', 0],
               mean_deaths_by_cause.loc['Malaria', 0],
               mean_total_deaths[0].values[0][0],
               mean_deaths_by_cause.loc['AIDS', 1],
               mean_deaths_by_cause.loc['TB (non-AIDS)', 1],
               mean_deaths_by_cause.loc['Malaria', 1],
               mean_total_deaths[1].values[0][0],
                mean_deaths_by_cause.loc['AIDS', 2],
               mean_deaths_by_cause.loc['TB (non-AIDS)', 2],
               mean_deaths_by_cause.loc['Malaria', 2],
               mean_total_deaths[2].values[0][0],
                mean_deaths_by_cause.loc['AIDS', 3],
               mean_deaths_by_cause.loc['TB (non-AIDS)', 3],
               mean_deaths_by_cause.loc['Malaria', 3],
               mean_total_deaths[3].values[0][0],
                mean_deaths_by_cause.loc['AIDS', 4],
               mean_deaths_by_cause.loc['TB (non-AIDS)', 4],
               mean_deaths_by_cause.loc['Malaria', 4],
               mean_total_deaths[4].values[0][0],
               ]

lower_deaths_for_plot = [mean_deaths_by_cause_lower.loc['AIDS', 0],
               mean_deaths_by_cause_lower.loc['TB (non-AIDS)', 0],
               mean_deaths_by_cause_lower.loc['Malaria', 0],
               lower_total_deaths[0].values[0][0],
               mean_deaths_by_cause_lower.loc['AIDS', 1],
               mean_deaths_by_cause_lower.loc['TB (non-AIDS)', 1],
               mean_deaths_by_cause_lower.loc['Malaria', 1],
               lower_total_deaths[1].values[0][0],
                mean_deaths_by_cause_lower.loc['AIDS', 2],
               mean_deaths_by_cause_lower.loc['TB (non-AIDS)', 2],
               mean_deaths_by_cause_lower.loc['Malaria', 2],
               lower_total_deaths[2].values[0][0],
                mean_deaths_by_cause_lower.loc['AIDS', 3],
               mean_deaths_by_cause_lower.loc['TB (non-AIDS)', 3],
               mean_deaths_by_cause_lower.loc['Malaria', 3],
               lower_total_deaths[3].values[0][0],
                mean_deaths_by_cause_lower.loc['AIDS', 4],
               mean_deaths_by_cause_lower.loc['TB (non-AIDS)', 4],
               mean_deaths_by_cause_lower.loc['Malaria', 4],
               lower_total_deaths[4].values[0][0],
               ]

upper_deaths_for_plot = [mean_deaths_by_cause_upper.loc['AIDS', 0],
               mean_deaths_by_cause_upper.loc['TB (non-AIDS)', 0],
               mean_deaths_by_cause_upper.loc['Malaria', 0],
               upper_total_deaths[0].values[0][0],
               mean_deaths_by_cause_upper.loc['AIDS', 1],
               mean_deaths_by_cause_upper.loc['TB (non-AIDS)', 1],
               mean_deaths_by_cause_upper.loc['Malaria', 1],
               upper_total_deaths[1].values[0][0],
                mean_deaths_by_cause_upper.loc['AIDS', 2],
               mean_deaths_by_cause_upper.loc['TB (non-AIDS)', 2],
               mean_deaths_by_cause_upper.loc['Malaria', 2],
               upper_total_deaths[2].values[0][0],
                mean_deaths_by_cause_upper.loc['AIDS', 3],
               mean_deaths_by_cause_upper.loc['TB (non-AIDS)', 3],
               mean_deaths_by_cause_upper.loc['Malaria', 3],
               upper_total_deaths[3].values[0][0],
                mean_deaths_by_cause_upper.loc['AIDS', 4],
               mean_deaths_by_cause_upper.loc['TB (non-AIDS)', 4],
               mean_deaths_by_cause_upper.loc['Malaria', 4],
               upper_total_deaths[4].values[0][0],
               ]

# Convert lists to numpy arrays
array1 = np.array(deaths_for_plot)
array2 = array1 - np.array(lower_deaths_for_plot)
array3 = np.array(upper_deaths_for_plot) - array1


# ---------------------------------------------------------------------------------------------

target_period = (datetime.date(2019, 1, 1), datetime.date(2020, 1, 1))

# life expectancy
# use file tlo/analysis/life_expectancy.py
le_estimates = get_life_expectancy_estimates(
    results_folder,
    target_period=target_period,
    summary=True)


xvals = np.arange(1, 21)

median_le = le_estimates.loc[:, le_estimates.columns.get_level_values(1) == 'mean']
median_le.columns = median_le.columns.get_level_values(0)
lower_le = le_estimates.loc[:, le_estimates.columns.get_level_values(1) == 'lower']
lower_le.columns = lower_le.columns.get_level_values(0)
upper_le = le_estimates.loc[:, le_estimates.columns.get_level_values(1) == 'upper']
upper_le.columns = upper_le.columns.get_level_values(0)


# error bar values w/ different -/+ errors that
# also vary with the x-position
lower_error = median_le - lower_le
upper_error = upper_le - median_le
asymmetric_error_m = np.array(list(zip(lower_error.loc['M'], upper_error.loc['M']))).T
asymmetric_error_f = np.array(list(zip(lower_error.loc['F'], upper_error.loc['F']))).T

colours = ['#0218a2', '#ffb703', '#f76f73', '#07c4c5']
sex_col = ['#673AB7', '#00897B']


# plot
fig, (ax1, ax2) = plt.subplots(2, sharex=False,
                               figsize=(10, 7))
fig.suptitle('')
plt.subplots_adjust(right=0.85)

# life expectancy
ax1.errorbar([0,4,8,12,16], median_le.loc['M'],
             yerr=asymmetric_error_m, fmt='x',
             color=sex_col[0],
             ecolor=sex_col[0])
ax1.errorbar([2,6,10,14,18], median_le.loc['F'],
             yerr=asymmetric_error_f, fmt='x',
             color=sex_col[1],
             ecolor=sex_col[1])

# Hide gridlines
ax1.grid(visible=False)

ax1.set_ylim(40, 75)
ax1.set_ylabel('Life expectancy, years')

ax1.set_xticks([])  # Remove tick labels

# Set y-axis tick marks and labels for ax1
ax1.set_yticks([45, 50, 55, 60, 65, 70])
ax1.set_yticklabels(['45', '50', '55', '60', '65', '70'])

for i in [3.5, 7.25, 10.75, 14.5]:
    ax1.axvline(x=i, color='grey', linestyle='--', linewidth=1)


# Custom legend handler for line
line_male = mlines.Line2D([], [], color=sex_col[0], marker='x', linestyle='-', markersize=5, label='Males')
line_female = mlines.Line2D([], [], color=sex_col[1], marker='x', linestyle='-', markersize=5, label='Females')

# Legend for ax1
ax1.legend(
    handles=[line_male, line_female],
    labels=['Males', 'Females'],
    loc='upper right',
    title='',
    fontsize='10',
    frameon=False,
    bbox_to_anchor=(1.175, 1)
)


# numbers of deaths
bars = ax2.bar(
    xvals,
    deaths_for_plot,
    color=colours
)

for bar, neg_err, pos_err, color in zip(bars,
                                        array2,
                                        array3, colours*5):
    plt.errorbar(x=bar.get_x() + bar.get_width() / 2,
                 y=bar.get_y() + bar.get_height(),
                 yerr=[[neg_err], [pos_err]],
                 color='black',  # Set error bar color to the same as the bars
                 capsize=5)

ax2.set_yscale('log')

ax2.set_ylabel('Number of deaths (log)')

for i in [4.5, 8.5, 12.5, 16.5]:
    ax2.axvline(x=i, color='grey', linestyle='--', linewidth=1)


# Custom tick labels for ax2
custom_tick_labels = [
    'Status quo',
    'Exclude HIV\nservices',
    'Exclude TB\nservices',
    'Exclude malaria\nservices',
    'Exclude HTM\nservices'
]
ax2.set_xticks([1.5, 6.0, 10.0, 14.5, 19.5])  # Set ticks at the midpoint of each group
ax2.set_xticklabels(custom_tick_labels, fontsize=10)

ax2.legend(
    handles=[plt.Rectangle((0, 0), 1, 1, color=color) for color in colours],
    labels=['AIDS', 'TB', 'Malaria', 'All causes'],
    loc='upper right',
    title='',
    fontsize='10',
    frameon=False,
    bbox_to_anchor=(1.2, 1)
)

fig.savefig(outputspath / "Mar2024_HTMresults/Death_life_expect_exclHTM.png")

plt.show()


# ---------------------------------------------------------------------------------------------
# sum the deaths averted through the single programmes to show difference from joint programmes

# get total deaths for each run 2010-2020
def get_total_deaths(results_folder, do_scaling=True):
    """ sum all deaths occurring for each run of each draw
    dataframe returned: row=total deaths, column=run/draw
    """
    def extract_deaths_total(df: pd.DataFrame) -> pd.Series:
        return pd.Series({"Total": len(df)})

    return extract_results(
        results_folder,
        module="tlo.methods.demography",
        key="death",
        custom_generate_series=extract_deaths_total,
        do_scaling=do_scaling
    )

total_deaths = get_total_deaths(results_folder)

# do run-by-run comparison, deaths in draw1 - draw0
def extract_difference_in_deaths_across_runs(total_deaths, scenario_info):
    """# this computes the mean difference in deaths between each scenario and baseline
    # numbers of deaths are compared run-for-run
    """
    out = [None] * scenario_info["number_of_draws"]
    for scenario in range(scenario_info["number_of_draws"]):
        deaths_difference_by_run = [
            total_deaths[scenario][run_number]["Total"] - total_deaths[0][run_number]["Total"]
            for run_number in range(scenario_info["runs_per_draw"])
        ]

        # Save each value of deaths_difference_by_run instead of computing the mean
        out[scenario] = deaths_difference_by_run
    df = pd.DataFrame(out, index=range(scenario_info["number_of_draws"]))

    return df

# the rows are scenarios, columns are runs
diffs_in_deaths = extract_difference_in_deaths_across_runs(total_deaths, scenario_info)

# to sum deaths averted by scenario:sum the deaths averted in each column 1:3
# this will be the all-cause deaths averted by HIV, TB and malaria programmes separately
# will have double-counting
# should be larger than the joint impact estimates
sum_values = diffs_in_deaths.iloc[1:4, :].sum()

# Add the sum values as a new row to the DataFrame
diffs_in_deaths.loc['Sum'] = sum_values


# Calculate median and percentiles for each row
row_stats = diffs_in_deaths.apply(lambda row: pd.Series([row.median(), row.quantile(0.025), row.quantile(0.975)]), axis=1)

# Rename the columns for clarity
row_stats.columns = ['Median', '2.5th Percentile', '97.5th Percentile']

print(row_stats)
