"""
Read in the output files generated by analysis_scenarios and plot outcomes for comparison
"""

import datetime
from pathlib import Path

import matplotlib.lines as mlines
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from tlo import Date

from tlo.analysis.utils import (
    compare_number_of_deaths,
    extract_params,
    extract_results,
    get_scenario_info,
    get_scenario_outputs,
    load_pickled_dataframes,
    summarize,
    make_age_grp_lookup,
    make_age_grp_types,
)

# outputspath = Path("./outputs/t.mangal@imperial.ac.uk")
outputspath = Path("./outputs")

# Find results_folder associated with a given batch_file (and get most recent [-1])
results_folder = get_scenario_outputs("effect_of_treatment_packages_combined.py", outputspath)[-1]

# Declare path for output graphs from this script
make_graph_file_name = lambda stub: results_folder / f"{stub}.png"  # noqa: E731

# look at one log (so can decide what to extract)
log = load_pickled_dataframes(results_folder)

# get basic information about the results
scenario_info = get_scenario_info(results_folder)

# Extract the parameters that have varied over the set of simulations
params = extract_params(results_folder)

# Create a list of strings summarizing the parameter values in the different draws
param_strings = [f"{row.module_param}={row.value}" for _, row in params.iterrows()]


# ----------------------------------------------------------------------
# extract deaths by year for life expectancy calculations

TARGET_PERIOD = (Date(2019, 1, 1), Date(2020, 1, 1))


# get mean number of deaths by age-group for the target period
def extract_deaths_by_age_sex(results_folder):
    """ extract numbers of deaths for each age-group
    return mean across runs
    return dataframe: rows=age_gp, columns=draw
    """
    def extract_deaths(df: pd.DataFrame) -> pd.Series:
        _, age_group_lookup = make_age_grp_lookup()
        df["Age_Grp"] = df["age"].map(age_group_lookup).astype(make_age_grp_types())
        df = df.rename(columns={"sex": "Sex"})
        return df.loc[pd.to_datetime(df.date).between(*TARGET_PERIOD)].groupby(["Age_Grp", "Sex"])["person_id"].count()

    return summarize(extract_results(
        results_folder,
        module="tlo.methods.demography",
        key="death",
        custom_generate_series=extract_deaths,
        do_scaling=True
    ), only_mean=True, collapse_columns=False
    )

deaths_by_age_sex = extract_deaths_by_age_sex(results_folder)

# get mean deaths by age and sex across the runs
deaths_f = deaths_by_age_sex.filter(like='F', axis=0)
deaths_f = deaths_f.reset_index()
# move column to index
deaths_f = deaths_f.set_index('Age_Grp')

baseline_deaths_f = deaths_f.iloc[:, 1]
excl_htm_deaths_f = deaths_f.iloc[:, 5]


deaths_m = deaths_by_age_sex.filter(like='M', axis=0)
deaths_m = deaths_m.reset_index()
# move column to index
deaths_m = deaths_m.set_index('Age_Grp')

baseline_deaths_m = deaths_m.iloc[:, 1]
excl_htm_deaths_m = deaths_m.iloc[:, 5]


# get person-years by age-group for target period
# use demography.age_range_m for pop size
# select target years
# for each column, take median
def extract_pop_size(results_folder, draw, key):
    module = "tlo.methods.demography"

    def get_multiplier(_draw, _run):
        """Helper function to get the multiplier from the simulation."""
        return load_pickled_dataframes(results_folder, _draw, _run, 'tlo.methods.population'
                                           )['tlo.methods.population']['scaling_factor']['scaling_factor'].values[0]

    # get number of draws and numbers of runs
    info = get_scenario_info(results_folder)

    # Dictionary to store DataFrames
    dataframes = {}

    # get the dataframes from each run
    for run in range(info['runs_per_draw']):

        df_name = f'df_{run}'  # Create a dynamic name for each DataFrame
        data = load_pickled_dataframes(results_folder, draw, run, module)[module][key]
        dataframes[df_name] = pd.DataFrame(data)

    # Concatenate DataFrames along a new axis (axis=2)
    concatenated_df = pd.concat([dataframes["df_1"],
                                 dataframes["df_2"],
                                 dataframes["df_3"],
                                 dataframes["df_4"],
                                 ], axis=1, keys=['df1', 'df2', 'df3', 'df4'])

    # Remove column 'B' from all data frames within concatenated_df
    concatenated_df = concatenated_df.drop('date', level=1, axis=1)
    # Calculate the mean for each row in each column
    tmp = concatenated_df.groupby(level=1, axis=1).mean() * get_multiplier(0, 0)

    return tmp


pop_baseline_m = extract_pop_size(results_folder=results_folder, draw=0, key="age_range_m")
pop_baseline_f = extract_pop_size(results_folder=results_folder, draw=0, key="age_range_f")
pop_exclHTM_m = extract_pop_size(results_folder=results_folder, draw=4,  key="age_range_m")
pop_exclHTM_f = extract_pop_size(results_folder=results_folder, draw=4,  key="age_range_f")


# select 2019 values for pop size
pop_baseline_m = pop_baseline_m.iloc[-1]
pop_baseline_f = pop_baseline_f.iloc[-1]
pop_exclHTM_m = pop_exclHTM_m.iloc[-1]
pop_exclHTM_f = pop_exclHTM_f.iloc[-1]

# create table for output
df = pd.concat([pop_baseline_m, baseline_deaths_m,
                pop_baseline_f, baseline_deaths_f], axis=1).reset_index()
df.columns = ['index', 'pop_baseline_m', 'baseline_deaths_m',
              'pop_baseline_f', 'baseline_deaths_f']

df.to_csv(outputspath /'Mar2024_HTMresults/baseline_life_expectancy.csv')

df1 = pd.concat([pop_exclHTM_m, excl_htm_deaths_m,
                  pop_exclHTM_f, excl_htm_deaths_f], axis=1).reset_index()
df1.columns = ['index', 'pop_exclHTM_m', 'excl_htm_deaths_m',
              'pop_exclHTM_f', 'excl_htm_deaths_f']

df1.to_csv(outputspath /'Mar2024_HTMresults/exclHTM_life_expectancy.csv')


TARGET_PERIOD = (datetime.date(2020, 1, 1), datetime.date(2019, 1, 1))

test = get_life_expectancy_estimates(results_folder, summary=True,
                                         target_period=TARGET_PERIOD)






