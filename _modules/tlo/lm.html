

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tlo.lm &mdash; TLOmodel 0.1.dev2471+g49acef5 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=d10597a4" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/theme_overrides.css?v=6ea10ece" />

  
    <link rel="shortcut icon" href="../../_static/favicon.png"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=cdb6c1d3"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            TLOmodel
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Welcome</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aims.html">Aims &amp; Objectives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../writeups.html">Model Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../data_sources.html">Data Sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../azure_batch.html">Using Azure Batch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources/index.html">Resource files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parameters.html">Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../learning.html">Learning Resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html">Contributors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">TLOmodel</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">tlo.lm</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for tlo.lm</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">builtins</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">prod</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">pandas.core.computation.parsing</span> <span class="kn">import</span> <span class="n">clean_column_name</span>

<span class="kn">from</span> <span class="nn">tlo</span> <span class="kn">import</span> <span class="n">logging</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>


<div class="viewcode-block" id="Predictor">
<a class="viewcode-back" href="../../reference/tlo.lm.html#tlo.lm.Predictor">[docs]</a>
<span class="k">class</span> <span class="nc">Predictor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">property_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">external</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">conditions_are_mutually_exclusive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">conditions_are_exhaustive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A Predictor variable for the regression model.</span>

<span class="sd">        :param property_name: A property of the population dataframe e.g. age, sex, etc.</span>
<span class="sd">            or if ``external=True`` the name of the external property that will be</span>
<span class="sd">            passed as a keyword argument to the ``LinearModel.predict`` method.</span>
<span class="sd">        :param external: Whether the named property is external (``True``) and so will</span>
<span class="sd">            be passed as a keyword argument to the ``LinearModel.predict`` method) or is</span>
<span class="sd">            a property of the population dataframe (``False``).</span>
<span class="sd">        :param conditions_are_mutually_exclusive: Whether the set of conditions that</span>
<span class="sd">            are declared for this predictor are all mutually exclusive, that is, for any</span>
<span class="sd">            pair of conditions, one condition evaluating to ``True`` implies the other</span>
<span class="sd">            must evaluate to ``False``. If this is declared to be the case a more</span>
<span class="sd">            efficient method of evaluation will be used in ``LinearModel.predict``. Note</span>
<span class="sd">            however that the validity of this declaration will not be checked so if this</span>
<span class="sd">            is set to ``True`` for predictors with non-mutually exclusive conditions,</span>
<span class="sd">            the model output will be erroneous.</span>
<span class="sd">        :param conditions_are_exhaustive: Whether the set of conditions that are</span>
<span class="sd">            declared for this predictor are all exhaustive, that is at least one</span>
<span class="sd">            condition will always be ``True`` irrespective of the value of the property.</span>
<span class="sd">            If this is declared to be the case, a more efficient method of evaluation</span>
<span class="sd">            maye be used in ``LinearModel.predict`, though if a catch-all ``otherwise``</span>
<span class="sd">            condition is included this flag will provide no benefit. Note that the</span>
<span class="sd">            validity of this declaration will not be checked so if this is set to</span>
<span class="sd">            ``True`` for predictors with non-exhaustive conditions, the model output</span>
<span class="sd">            will be erroneous.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">property_name</span> <span class="o">=</span> <span class="n">property_name</span>

        <span class="c1"># If this is a property that is not part of the population dataframe</span>
        <span class="k">if</span> <span class="n">external</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">property_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Can&#39;t have an unnamed external predictor&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">property_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;__</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">property_name</span><span class="si">}</span><span class="s1">__&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">conditions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_otherwise</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conditions_are_mutually_exclusive</span> <span class="o">=</span> <span class="n">conditions_are_mutually_exclusive</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conditions_are_exhaustive</span> <span class="o">=</span> <span class="n">conditions_are_exhaustive</span>

<div class="viewcode-block" id="Predictor.when">
<a class="viewcode-back" href="../../reference/tlo.lm.html#tlo.lm.Predictor.when">[docs]</a>
    <span class="k">def</span> <span class="nf">when</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Predictor&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Can&#39;t use `when` on Predictor with function&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span><span class="p">(</span><span class="n">condition</span><span class="o">=</span><span class="n">condition</span><span class="p">,</span> <span class="n">coefficient</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="Predictor.otherwise">
<a class="viewcode-back" href="../../reference/tlo.lm.html#tlo.lm.Predictor.otherwise">[docs]</a>
    <span class="k">def</span> <span class="nf">otherwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Predictor&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Can&#39;t use `otherwise` condition on unnamed Predictor&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Can&#39;t use `otherwise` on Predictor with function&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span><span class="p">(</span><span class="n">coefficient</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="Predictor.apply">
<a class="viewcode-back" href="../../reference/tlo.lm.html#tlo.lm.Predictor.apply">[docs]</a>
    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;Predictor&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Can&#39;t use `apply` on unnamed Predictor&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conditions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Can&#39;t specify `apply` on Predictor with when/otherwise conditions&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Can&#39;t specify more than one callback for a Predictor&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span>
        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="k">def</span> <span class="nf">_coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Predictor&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds the coefficient for the Predictor. The arguments can be two:</span>
<span class="sd">                `coeff(condition, value)` where the condition evaluates the property value to true/false</span>
<span class="sd">                `coeff(value)` where the value is given to all unconditioned values of the property</span>
<span class="sd">        The second style (unconditioned value) only makes sense after one or more conditioned values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If there isn&#39;t a property name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We use the supplied condition literally</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conditions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">condition</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># Otherwise, the condition is applied on a specific property</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># Handle either a complex condition (begins with an operator) or implicit equality</span>
            <span class="k">if</span> <span class="n">condition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;!&#39;</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;~&#39;</span><span class="p">,</span> <span class="s1">&#39;(&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">]:</span>
                <span class="n">parsed_condition</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">property_name</span><span class="si">}{</span><span class="n">condition</span><span class="si">}</span><span class="s1">)&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># numeric values don&#39;t need to be quoted</span>
                <span class="k">if</span> <span class="n">condition</span><span class="o">.</span><span class="n">isnumeric</span><span class="p">():</span>
                    <span class="n">parsed_condition</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">property_name</span><span class="si">}</span><span class="s1"> == </span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s1">)&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">parsed_condition</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">property_name</span><span class="si">}</span><span class="s1"> == &quot;</span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s1">&quot;)&#39;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">condition</span><span class="p">:</span>
                <span class="n">parsed_condition</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">property_name</span><span class="si">}</span><span class="s1"> == True)&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parsed_condition</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">property_name</span><span class="si">}</span><span class="s1"> == False)&#39;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
            <span class="n">parsed_condition</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">property_name</span><span class="si">}</span><span class="s1"> == </span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s1">)&#39;</span>
        <span class="k">elif</span> <span class="n">condition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_otherwise</span><span class="p">,</span> <span class="s2">&quot;You can only give one unconditioned value to predictor&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">has_otherwise</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">parsed_condition</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unhandled condition: </span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">conditions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">parsed_condition</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_name</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">property_name</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1"> (external)&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> -&gt; callback(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">previous_condition</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">condition</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">conditions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">condition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="s2">&quot; &quot;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">previous_condition</span><span class="p">)</span><span class="si">}</span><span class="s1"> -&gt; </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1"> (otherwise)&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">previous_condition</span> <span class="o">=</span> <span class="n">condition</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>



<div class="viewcode-block" id="LinearModelType">
<a class="viewcode-back" href="../../reference/tlo.lm.html#tlo.lm.LinearModelType">[docs]</a>
<span class="k">class</span> <span class="nc">LinearModelType</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The type of model specifies how the results from the predictor are combined:</span>
<span class="sd">    &#39;additive&#39; -&gt; adds the effect_sizes from the predictors</span>
<span class="sd">    &#39;logisitic&#39; -&gt; multiples the effect_sizes from the predictors and applies the transform x/(1+x)</span>
<span class="sd">    [Thus, the intercept can be taken to be an Odds and effect_sizes Odds Ratios,</span>
<span class="sd">    and the prediction is a probability.]</span>
<span class="sd">    &#39;multiplicative&#39; -&gt; multiplies the effect_sizes from the predictors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ADDITIVE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">LOGISTIC</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">MULTIPLICATIVE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="c1"># the &#39;custom&#39; is used internally by the custom() method</span>
    <span class="n">CUSTOM</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span></div>



<div class="viewcode-block" id="LinearModel">
<a class="viewcode-back" href="../../reference/tlo.lm.html#tlo.lm.LinearModel">[docs]</a>
<span class="k">class</span> <span class="nc">LinearModel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lm_type</span><span class="p">:</span> <span class="n">LinearModelType</span><span class="p">,</span>
        <span class="n">intercept</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="o">*</span><span class="n">predictors</span><span class="p">:</span> <span class="n">Predictor</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A linear model has an intercept and zero or more ``Predictor`` variables.</span>

<span class="sd">        :param lm_type: Model type to use.</span>
<span class="sd">        :param intercept: Intercept term for the model.</span>
<span class="sd">        :param *predictors: Any ``Predictor`` instances to use in computing output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">lm_type</span> <span class="ow">in</span> <span class="n">LinearModelType</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;Model should be one of the prescribed LinearModelTypes&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lm_type</span> <span class="o">=</span> <span class="n">lm_type</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">intercept</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">)),</span> <span class="p">(</span>
            <span class="s2">&quot;Intercept is not specified or wrong type.&quot;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">intercept</span><span class="p">),</span> <span class="s2">&quot;Intercept must not be NaN or infinite&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intercept</span> <span class="o">=</span> <span class="n">intercept</span>

        <span class="c1"># Store predictors as tuple and expose via read-only property to prevent</span>
        <span class="c1"># updates after model initialisation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_predictors</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">predictors</span><span class="p">)</span>
        <span class="n">non_predictors</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predictors</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Predictor</span><span class="p">)]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_predictors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;One or more predictors are of invalid type: </span><span class="si">{</span><span class="n">non_predictors</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_predictors</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lm_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LinearModelType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The model type.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lm_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">intercept</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The intercept value for the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intercept</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">predictors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Predictor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The predictors used in calculating the model output.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predictors</span>

<div class="viewcode-block" id="LinearModel.multiplicative">
<a class="viewcode-back" href="../../reference/tlo.lm.html#tlo.lm.LinearModel.multiplicative">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">multiplicative</span><span class="p">(</span><span class="o">*</span><span class="n">predictors</span><span class="p">:</span> <span class="n">Predictor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a multplicative LinearModel with intercept=1.0</span>

<span class="sd">        :param predictors: One or more Predictor objects defining the model</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">LinearModel</span><span class="p">(</span><span class="n">LinearModelType</span><span class="o">.</span><span class="n">MULTIPLICATIVE</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="o">*</span><span class="n">predictors</span><span class="p">)</span></div>


<div class="viewcode-block" id="LinearModel.custom">
<a class="viewcode-back" href="../../reference/tlo.lm.html#tlo.lm.LinearModel.custom">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">custom</span><span class="p">(</span><span class="n">predict_function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Define a linear model using the supplied function</span>

<span class="sd">        The function acts as a drop-in replacement to the predict function and must</span>
<span class="sd">        implement the interface:</span>

<span class="sd">            (</span>
<span class="sd">                self: LinearModel,</span>
<span class="sd">                df: Union[pd.DataFrame, pd.Series],</span>
<span class="sd">                rng: Optional[np.random.RandomState] = None,</span>
<span class="sd">                **kwargs</span>
<span class="sd">            ) -&gt; pd.Series</span>

<span class="sd">        It is the responsibility of the caller of predict to ensure they pass either</span>
<span class="sd">        a dataframe or an individual record as expected by the custom function.</span>

<span class="sd">        See test_custom() in test_lm.py for a couple of examples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create an instance of a custom linear model</span>
        <span class="n">custom_model</span> <span class="o">=</span> <span class="n">LinearModel</span><span class="p">(</span><span class="n">LinearModelType</span><span class="o">.</span><span class="n">CUSTOM</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># replace this instance&#39;s predict method</span>
        <span class="c1"># see https://stackoverflow.com/a/28127947</span>
        <span class="n">custom_model</span><span class="o">.</span><span class="n">predict</span> <span class="o">=</span> <span class="n">predict_function</span><span class="o">.</span><span class="fm">__get__</span><span class="p">(</span><span class="n">custom_model</span><span class="p">,</span> <span class="n">LinearModel</span><span class="p">)</span>
        <span class="c1"># save value to any keyword arguments inside of this linear model</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># check the name doesn&#39;t already exist</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">custom_model</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot store argument &#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&#39; as name already exists; change name.&quot;</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">custom_model</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">custom_model</span></div>


    <span class="k">def</span> <span class="nf">_parse_predictors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set model string, callback predictors and predictor names from predictors.</span>

<span class="sd">        Sets `self._model_string` to an expression string (to be evaluated by</span>
<span class="sd">        ``pandas.DataFrame.eval``) corresponding to the evaluation of the model output</span>
<span class="sd">        for the subset of the predictors which do not define a custom callback function</span>
<span class="sd">        and the model intercept, or an empty string if no non-callback predictors are</span>
<span class="sd">        present.</span>

<span class="sd">        Additionally sets `self._callback_predictors` to a tuple of the omitted</span>
<span class="sd">        predictors with custom callback functions and `self._predictor_names` to a set</span>
<span class="sd">        of strings corresponding to names specified in the predictors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For additive models a zero coefficient corresponds to no effect while for</span>
        <span class="c1"># multiplicative and logistic models the relevant value is one</span>
        <span class="n">null_coeff_value</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lm_type</span> <span class="o">==</span> <span class="n">LinearModelType</span><span class="o">.</span><span class="n">ADDITIVE</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="n">predictor_strings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">callback_predictors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_predictor_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">predictor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predictors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">predictor</span><span class="o">.</span><span class="n">callback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">predictor</span><span class="o">.</span><span class="n">property_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_predictor_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">predictor</span><span class="o">.</span><span class="n">property_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If no property_name specified, predictor conditions will</span>
                    <span class="c1"># contain one or more column names therefore parse condition</span>
                    <span class="c1"># strings and filter for all name nodes. This will also</span>
                    <span class="c1"># add non-column names such as builtin functions so need to</span>
                    <span class="c1"># check if names are actually columns before using</span>
                    <span class="k">for</span> <span class="n">condition</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">predictor</span><span class="o">.</span><span class="n">conditions</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_predictor_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                            <span class="n">node</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">ast</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">condition</span><span class="p">))</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">)</span>
                        <span class="p">)</span>
                <span class="n">has_catch_all_condition</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">predictor</span><span class="o">.</span><span class="n">conditions</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">condition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="c1"># &#39;otherwise&#39; fallback condition - always True. If used as</span>
                            <span class="c1"># first condition any other conditions will be ignored as</span>
                            <span class="c1"># this condition matches all</span>
                            <span class="n">predictor_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="n">any_prev_conds</span> <span class="o">=</span> <span class="s2">&quot;True&quot;</span>
                            <span class="n">has_catch_all_condition</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">predictor_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s2">) * </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="n">any_prev_conds</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">condition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="c1"># &#39;otherwise&#39; fallback condition - matches all not</span>
                            <span class="c1"># so far matched therefore can ignore any remaining</span>
                            <span class="c1"># conditions</span>
                            <span class="n">predictor_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; + (~(</span><span class="si">{</span><span class="n">any_prev_conds</span><span class="si">}</span><span class="s2">)) * </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="n">has_catch_all_condition</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                        <span class="k">elif</span> <span class="n">predictor</span><span class="o">.</span><span class="n">conditions_are_mutually_exclusive</span><span class="p">:</span>
                            <span class="c1"># conditions have been declared to be mutually exclusive</span>
                            <span class="c1"># therefore we can just multiply conditions by coefficient</span>
                            <span class="c1"># values as condition == ~any_prev_conds &amp; condition</span>
                            <span class="n">predictor_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; + (</span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s2">) * </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="n">any_prev_conds</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; | </span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s2">&quot;</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># conditions are potentially non-mutually exclusive and</span>
                            <span class="c1"># are applied sequentially in order specified on subset</span>
                            <span class="c1"># not matching any previous conditions</span>
                            <span class="n">predictor_str</span> <span class="o">+=</span> <span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot; + (~(</span><span class="si">{</span><span class="n">any_prev_conds</span><span class="si">}</span><span class="s2">) &amp; </span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s2">) * </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">any_prev_conds</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; | </span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="c1"># If the predictor neither declares that the conditions are exhaustive</span>
                <span class="c1"># (i.e. all cases are covered an any_prev_conds is guaranteed to be</span>
                <span class="c1"># True) nor an &#39;otherwise&#39; catch-all condition has been used (in which</span>
                <span class="c1"># case any_prev_conds is also guaranteed to be True) then add term</span>
                <span class="c1"># corresponding to no effect when no previous conditions matched</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">predictor</span><span class="o">.</span><span class="n">conditions_are_exhaustive</span> <span class="ow">or</span> <span class="n">has_catch_all_condition</span><span class="p">):</span>
                    <span class="n">predictor_str</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; + ~(</span><span class="si">{</span><span class="n">any_prev_conds</span><span class="si">}</span><span class="s2">) * </span><span class="si">{</span><span class="n">null_coeff_value</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">predictor_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">predictor_str</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_predictor_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">predictor</span><span class="o">.</span><span class="n">property_name</span><span class="p">)</span>
                <span class="n">callback_predictors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">predictor</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_callback_predictors</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">callback_predictors</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">predictor_strings</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span> <span class="o">!=</span> <span class="n">null_coeff_value</span><span class="p">:</span>
                <span class="c1"># Only need to include intercept if its non-zero in additive models</span>
                <span class="c1"># or non-unity in multiplicative/logistic models</span>
                <span class="n">predictor_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lm_type</span> <span class="o">==</span> <span class="n">LinearModelType</span><span class="o">.</span><span class="n">ADDITIVE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_model_string</span> <span class="o">=</span> <span class="s2">&quot; + &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">predictor_strings</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_model_string</span> <span class="o">=</span> <span class="s2">&quot; * &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">predictor_strings</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_column_resolvers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="o">**</span><span class="n">external_variables</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct mapping from predictor column names to column values.</span>

<span class="sd">        For use in ``resolvers`` argument to ``pandas.eval`` call.</span>

<span class="sd">        Compared to ``pandas.DataFrame._get_cleaned_column_resolvers()`` here only the</span>
<span class="sd">        column names present in the model predictors are included when constructing the</span>
<span class="sd">        returned dictionary. For dataframes with a large number of columns this is more</span>
<span class="sd">        performant than iterating over all columns, of which typically only a small</span>
<span class="sd">        subset are used in each linear model. Any external variables specified in</span>
<span class="sd">        predictors are also included with dunder-wrapped keys (e.g &#39;__ext_var__&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">column_resolvers</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predictor_names</span><span class="p">:</span>
            <span class="c1"># predictor_names may contain built-in names that are not columns</span>
            <span class="c1"># therefore we need to check if name is column in dataframe</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cleaned_name</span> <span class="o">=</span> <span class="n">clean_column_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">CategoricalDtype</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">categories</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="c1"># `pandas.eval` raises an error when using boolean operations</span>
                    <span class="c1"># on series with a categorical dtype with integer categories</span>
                    <span class="c1"># therefore if any such columns are present we convert to</span>
                    <span class="c1"># double-precision floats - this should be safe providing only</span>
                    <span class="c1"># integer categories which have exact floating point representations</span>
                    <span class="c1"># are used (which is likely to be the case)</span>
                    <span class="n">column_resolvers</span><span class="p">[</span><span class="n">cleaned_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">column_resolvers</span><span class="p">[</span><span class="n">cleaned_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">external_variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">column_resolvers</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;__</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">column_resolvers</span>

<div class="viewcode-block" id="LinearModel.predict">
<a class="viewcode-back" href="../../reference/tlo.lm.html#tlo.lm.LinearModel.predict">[docs]</a>
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">rng</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">squeeze_single_row_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate linear model output for a given set of input data.</span>

<span class="sd">        :param df: The input ``DataFrame`` containing the input data to evaluate the</span>
<span class="sd">          model with.</span>
<span class="sd">        :param rng: If set to a NumPy ``RandomState`` instance, returned output will</span>
<span class="sd">          be boolean ``Series`` corresponding to Bernoulli random variables sampled</span>
<span class="sd">          according to probabilities specified by model output. Otherwise model</span>
<span class="sd">          output directly returned.</span>
<span class="sd">        :param squeeze_single_row_output: If ``rng`` argument is not ``None`` and this</span>
<span class="sd">          argument is set to ``True``, the output for a ``df`` input with a single-row</span>
<span class="sd">          will be a scalar boolean value rather than a boolean ``Series``.</span>
<span class="sd">        :param **kwargs: Values for any external variables included in model</span>
<span class="sd">          predictors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that all names specified in predictors are either a column name, an</span>
        <span class="c1"># external variable in kwargs (with __ prefix/suffix removed) or a built-in</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_predictor_names</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">name</span> <span class="ow">in</span> <span class="n">df</span>
                <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">kwargs</span>
                <span class="p">)</span>
                <span class="ow">or</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">builtins</span><span class="o">.</span><span class="vm">__dict__</span>
            <span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Predictors include unknown name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">column_resolvers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_column_resolvers</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_string</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_model_string</span><span class="p">,</span>
                <span class="n">resolvers</span><span class="o">=</span><span class="p">(</span><span class="n">column_resolvers</span><span class="p">,),</span>
                <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;python&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_callback_predictors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">callback_results</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">column_resolvers</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">property_name</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">callback</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_callback_predictors</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lm_type</span> <span class="o">==</span> <span class="n">LinearModelType</span><span class="o">.</span><span class="n">ADDITIVE</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">callback_results</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">*=</span> <span class="n">prod</span><span class="p">(</span><span class="n">callback_results</span><span class="p">)</span>

        <span class="c1"># Ensure result of floating point type even if all predictor coefficients</span>
        <span class="c1"># are integer but intercept is floating point</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># Result series sometimes picks up name from one of predictors - set to</span>
        <span class="c1"># None so comparisons with unnamed series in tests pass</span>
        <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lm_type</span> <span class="o">==</span> <span class="n">LinearModelType</span><span class="o">.</span><span class="n">LOGISTIC</span><span class="p">:</span>
            <span class="c1"># Below is equivalent to result = result / (1 + result) but will give correct</span>
            <span class="c1"># output where any elements in result are inf (--&gt; 1.0) or 0.0 (--&gt; 0.0).</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">result</span><span class="p">))</span>

        <span class="c1"># If the user supplied a random number generator then they want outcomes,</span>
        <span class="c1"># not probabilities</span>
        <span class="k">if</span> <span class="n">rng</span><span class="p">:</span>
            <span class="n">outcome</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">result</span>
            <span class="c1"># pop the boolean out of the series if we have a single row,</span>
            <span class="c1"># otherwise return the series</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outcome</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">squeeze_single_row_output</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">outcome</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">outcome</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span></div>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;LinearModel(</span><span class="se">\n</span><span class="s2">&quot;</span>\
              <span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lm_type</span><span class="si">}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>\
              <span class="sa">f</span><span class="s2">&quot;  intercept = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="si">}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">predictor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">predictors</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;  </span><span class="si">{</span><span class="n">predictor</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">return</span> <span class="n">out</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
      <span class="lastupdated">Last updated on Nov 19, 2024.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>