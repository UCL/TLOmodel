name: Calibration

on:
  push:
    branches: "master"
  workflow_dispatch:
    inputs:
      commit:
        description: 'Commit'
        required: true
        default: ""
        type: string

env:
  REPO_PATH:       /mnt/tlo/TLOmodel
  OUTPUT_ROOT:     /mnt/tlodev2stg/tlo-dev-fs-2/task-runner/output
  RUNS_NUMBER:     14
  PYTHON_VER:      3.11
  RUN_NAME:        021_long_run_all_diseases_run
  PROCESS_NAME:    022_long_run_all_diseases_process

jobs:

  # Do a single clone from the remote repository, to reduce bandwidth usage.
  # The repo is cloned to a directory outside of the runner workspace, because
  # we want it to survive the current job, but this also means we can't use the
  # `actions/checkout` workflow.
  setup:
    name: Setup
    runs-on: [tlo-dev-vm-1]
    strategy:
      fail-fast: false
    outputs:
      environment_path: ${{ steps.vars.outputs.environment_path }}
      worktree_path: ${{ steps.vars.outputs.worktree_path }}
      output_dir: ${{ steps.out-dir.outputs.output_dir }}
      tasks: ${{ steps.tasks.outputs.tasks }}
    steps:
      - name: Generate environment variables
        id: vars
        run: |
          if [[ ${{ github.event_name }} == 'workflow_dispatch' ]] && [[ -n "${{ inputs.commit }}" ]]; then
              SHA=${{ inputs.commit }}
          else
              SHA=${{ github.sha }}
          fi
          ENV="/mnt/tlo/env-${SHA}"
          WORKTREE_PATH="/mnt/tlo/${SHA}"
          echo "SHA=${SHA}"
          echo "SHA=${SHA}" >> "${GITHUB_ENV}"
          echo "ENV=${ENV}"
          echo "ENV=${ENV}" >> "${GITHUB_ENV}"
          echo "environment_path=${ENV}" >> "${GITHUB_OUTPUT}"
          echo "WORKTREE_PATH=${WORKTREE_PATH}"
          echo "WORKTREE_PATH=${WORKTREE_PATH}" >> "${GITHUB_ENV}"
          echo "worktree_path=${WORKTREE_PATH}" >> "${GITHUB_OUTPUT}"

      - name: Clone remote TLO repository and fetch desired commit
        run: |
          # If the repository doesn't exist on disk, clone it.
          if [[ ! -d "${REPO_PATH}" ]]; then
              git clone --depth=1 --branch="${{ github.ref_name }}" "https://github.com/${{ github.repository }}.git" "${REPO_PATH}"
          fi
          # In any case, fetch the requested commit.
          git -C "${REPO_PATH}" fetch --depth=1 origin "${SHA}"

      - name: Create worktree
        run: |
          git -C "${REPO_PATH}" worktree add "${WORKTREE_PATH}" ${SHA}

      - name: Create virtual environment
        run: |
          python${PYTHON_VER} -m venv "${ENV}"
          source "${ENV}/bin/activate"
          pip install -r requirements/dev.txt
          pip install -e .
        working-directory: "${{ env.WORKTREE_PATH }}"

      - name: Generate output directory
        id: out-dir
        run: |
          commit_dir=$(git show -s --date=format:'%Y-%m-%d_%H%M%S' --format=%cd_%h "${SHA}")
          output_dir="${OUTPUT_ROOT}/${commit_dir}"
          echo "output_dir=${output_dir}"
          echo "output_dir=${output_dir}" >> "${GITHUB_OUTPUT}"
        working-directory: "${{ env.WORKTREE_PATH }}"

      - name: Generate list of tasks
        id: tasks
        run: |
          RUNS="["
          for run in $(seq 0 $((${RUNS_NUMBER} - 1))); do
              RUNS="${RUNS}\"${run}\","
          done
          RUNS="${RUNS}]"
          echo "tasks=${RUNS}"
          echo "tasks=${RUNS}" >> "${GITHUB_OUTPUT}"

  # Run the tasks.
  tasks:
    needs: setup
    name: Run task ${{ matrix.index }}
    runs-on: [tlo-dev-vm-1, tasks] # Use only runners dedicated to running the tasks.
    timeout-minutes: 5760 # = 4 * 24 * 60 minutes = 4 days
    strategy:
      fail-fast: false
      matrix:
        index: ${{ fromJSON(needs.setup.outputs.tasks) }}
    steps:
      - name: Run the task
        run: |
          source "${{ needs.setup.outputs.environment_path }}/bin/activate"
          draw=0
          task_output_dir="${{ needs.setup.outputs.output_dir }}/${RUN_NAME}/${draw}/${{ matrix.index }}"
          mkdir -p "${task_output_dir}"

          tlo scenario-run --output-dir "${task_output_dir}" --draw "${draw}" ${{ matrix.index }} "${{ needs.setup.outputs.worktree_path }}/src/scripts/calibration_analyses/scenarios/long_run_all_diseases.py"
        working-directory: "${{ needs.setup.outputs.worktree_path }}"

  # Do the postprocessing
  postprocess:
    name: Post processing
    needs: [setup, tasks]
    runs-on: [tlo-dev-vm-1, postprocess] # Use only the runners dedicated to postprocessing
    strategy:
      fail-fast: false
    steps:
      - name: Run post-processing
        run: |
          source "${{ needs.setup.outputs.environment_path }}/bin/activate"
          task_output_dir="${{ needs.setup.outputs.output_dir }}/${PROCESS_NAME}"
          mkdir -p "${task_output_dir}"

          python3 "${{ needs.setup.outputs.worktree_path }}/src/scripts/calibration_analyses/analysis_scripts/process.py" "${task_output_dir}" "${RUN_NAME}" "${{ needs.setup.outputs.worktree_path }}/resources"
        working-directory: "${{ needs.setup.outputs.worktree_path }}"

  # Cleanup stage, to remove temporary directories and such
  cleanup:
    name: Cleanup job
    # It depends on all the previous jobs, but it always runs, regardless of
    # their success (or maybe check that only `setup` was
    # successful?)
    if: ${{ always() }}
    timeout-minutes: 10
    needs: [setup, tasks, postprocess]
    runs-on: [tlo-dev-vm-1]
    strategy:
      fail-fast: false
    steps:
      - name: Cleanup worktree
        run: |
          git -C "${REPO_PATH}" worktree remove -f "${{ needs.setup.outputs.worktree_path }}" || true

      - name: Cleanup virtual environment
        run: |
          rm -rvf "${{ needs.setup.outputs.environment_path }}"
