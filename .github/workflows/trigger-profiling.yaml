name: Trigger Profiling

on:
  workflow_dispatch:
  # Allow profiling to be triggered by comments on pull requests
  # Trigger is /run profiling
  issue_comment:
    types:
      - created
  # Profile the model every Sunday at 00:00, 
  # on the HEAD of master
  schedule:
    - cron: 0 0 * * 6

jobs:
  not-comment-triggered:
    runs-on: self-hosted
    if: github.event_name != 'issue_comment'
    steps:
    - name: Run profiling when not triggered by a comment
      uses: ./.github/workflows/run-profiling.yaml
      with:
        event-name: ${{ github.event_name }}
        run-number: ${{ github.run_number }}
        sha: ${{ github.sha }}
      secrets:
        ## The token provided needs contents and pages access to the target repo
        ## Token can be (re)generated by a member of the UCL organisation, 
        ## the current member is the rc-softdev-admin.
        ## [10-07-2023] The current token will expire 10-07-2024
        profiling-access-token: ${{ secrets.PROFILING_REPO_ACCESS }}

  comment-triggered:
    runs-on: self-hosted
    if: github.event_name == 'issue_comment' && github.event.comment.body == format('/run {0}', profiling)
    steps:
    - name: Check permissions of commenting user
      id: has_permissions
      uses: actions/github-script@v6
      with:
        script: |
          const response = await github.rest.repos.getCollaboratorPermissionLevel({
            owner: context.repo.owner,
            repo: context.repo.repo,  
            username: context.payload.comment.user.login,
          });
          const permission_level = response.data.permission;
          return (permission_level == 'admin') || (permission_level == 'write')
    - name: Exit if insufficient permissions
      if: ${{ steps.has_permissions.outputs.result == 'false' }}
      run: |
        exit 1
    - name: React to comment
      uses: actions/github-script@v6
      with:
        script: |
          github.rest.reactions.createForIssueComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            comment_id: context.payload.comment.id,
            content: "rocket",
          });
    - name: Get SHA of last commit on default branch if issue or pull-request branch
      id: sha
      uses: actions/github-script@v6
      with:
        result-encoding: string
        script: |
          if (!context.payload.pull_request) {
            return context.sha;
          };
          const { data: pr } = await github.rest.pulls.get({
            owner: context.issue.owner,
            repo: context.issue.repo,
            pull_number: context.issue.number,
          });
          return pr.head.sha;
    - name: Trigger profiling workflow
      uses: ./.github/workflows/run-profiling.yaml
      with:
        event-name: ${{ github.event_name }}
        run-number: ${{ github.run_number }}
        sha: ${{ steps.sha.outputs.result }}
      secrets:
        ## The token provided needs contents and pages access to the target repo
        ## Token can be (re)generated by a member of the UCL organisation, 
        ## the current member is the rc-softdev-admin.
        ## [10-07-2023] The current token will expire 10-07-2024
        profiling-access-token: ${{ secrets.PROFILING_REPO_ACCESS }}
    - name: Get comment-bot token
      if: always() && steps.has_permissions.outputs.result == 'true'
      id: get_comment_bot_token
      uses: peter-murray/workflow-application-token-action@e8782d687a306fb13d733244d0f2a50e272d3752
      with:
        application_id: ${{ secrets.COMMENT_BOT_APP_ID }}
        application_private_key: ${{ secrets.COMMENT_BOT_APP_PRIVATE_KEY }}
        organization: ${{ inputs.application-organization }}
    - name: Create comment with test result and link to workflow run information
      if: always() && steps.has_permissions.outputs.result == 'true'
      uses: actions/github-script@v6
      with:
        github-token: ${{ steps.get_comment_bot_token.outputs.token }}
        script: |
          // There can be a delay between steps completing and this being reflected
          // in information queried from REST API, therefore we poll for the list of
          // jobs associated with workflow run at interval of 1 second until the
          // status of the previous "Run test command(s)" step indicates completed or
          // a maximum number of attempts have been reached
          const maximum_attempts = 5;
          let got_completed_step_info = false;
          let attempts = 0;
          let job, step;
          while (!got_completed_step_info & attempts < maximum_attempts) {
            await new Promise(r => setTimeout(r, 1000));  // Wait for 1 second
            const { data: run_jobs } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId,
            });
            const in_progress_jobs = run_jobs.jobs.filter(
              job => job.status == "in_progress"
            );  
            // There should only be only one job in progress
            if (in_progress_jobs.length > 1) {
              throw "Multiple jobs triggered by same keyword";
            }
            job = in_progress_jobs[0];
            const run_test_commands_steps = job.steps.filter(
              step => step.name == "Run test command(s)"
            );
            // There should only be one step with name "Run test command(s)"
            if (run_test_commands_steps.length > 1) {
              throw "Multiple steps with name 'Run test command(s)'";
            }
            step = run_test_commands_steps[0];
            got_completed_step_info = (step.status == "completed");
            attempts += 1;
          }
          if (!got_completed_step_info) {
            throw `Could not get completed step data in ${maximum_attempts} attempts`;
          }
          const result = step.conclusion == 'success' ? 'succeeded ✅' : 'failed ❌';
          const started_date = new Date(step.started_at);
          const completed_date = new Date(step.completed_at);
          const time_minutes = ((completed_date - started_date) / 60000).toPrecision(3);
          const details = [
            `#️⃣ ${{ steps.sha.outputs.result }}`
          ].join('\n');
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,  
            body: `## Profiling run requested. Success: ${result}\n[Check the profiling results here.](http://github-pages.ucl.ac.uk/TLOmodel-profiling/profiling.html)\n${details}`
          });
